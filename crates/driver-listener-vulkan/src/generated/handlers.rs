//! THIS FILE IS GENERATED BY TOOL, DO NOT MODIFY.

use ash::vk;
use wie_driver_common_vulkan::generated::vulkan_types::*;
use crate::Packet;

pub(crate) fn register_handlers_to(map: &mut crate::HandlerMap) {
    map.insert(1000001000, Box::new(vk_create_instance));
    map.insert(1000001001, Box::new(vk_destroy_instance));
    map.insert(1000001002, Box::new(vk_enumerate_physical_devices));
    map.insert(1000001003, Box::new(vk_get_device_proc_addr));
    map.insert(1000001004, Box::new(vk_get_instance_proc_addr));
    map.insert(1000001005, Box::new(vk_get_physical_device_properties));
    map.insert(1000001006, Box::new(vk_get_physical_device_queue_family_properties));
    map.insert(1000001007, Box::new(vk_get_physical_device_memory_properties));
    map.insert(1000001008, Box::new(vk_get_physical_device_features));
    map.insert(1000001009, Box::new(vk_get_physical_device_format_properties));
    map.insert(1000001010, Box::new(vk_get_physical_device_image_format_properties));
    map.insert(1000001011, Box::new(vk_create_device));
    map.insert(1000001012, Box::new(vk_destroy_device));
    map.insert(1000001013, Box::new(vk_enumerate_instance_version));
    map.insert(1000001014, Box::new(vk_enumerate_instance_layer_properties));
    map.insert(1000001015, Box::new(vk_enumerate_instance_extension_properties));
    map.insert(1000001016, Box::new(vk_enumerate_device_layer_properties));
    map.insert(1000001017, Box::new(vk_enumerate_device_extension_properties));
    map.insert(1000001018, Box::new(vk_get_device_queue));
    map.insert(1000001019, Box::new(vk_queue_submit));
    map.insert(1000001020, Box::new(vk_queue_wait_idle));
    map.insert(1000001021, Box::new(vk_device_wait_idle));
    map.insert(1000001022, Box::new(vk_allocate_memory));
    map.insert(1000001023, Box::new(vk_free_memory));
    map.insert(1000001024, Box::new(vk_map_memory));
    map.insert(1000001025, Box::new(vk_unmap_memory));
    map.insert(1000001026, Box::new(vk_flush_mapped_memory_ranges));
    map.insert(1000001027, Box::new(vk_invalidate_mapped_memory_ranges));
    map.insert(1000001028, Box::new(vk_get_device_memory_commitment));
    map.insert(1000001029, Box::new(vk_get_buffer_memory_requirements));
    map.insert(1000001030, Box::new(vk_bind_buffer_memory));
    map.insert(1000001031, Box::new(vk_get_image_memory_requirements));
    map.insert(1000001032, Box::new(vk_bind_image_memory));
    map.insert(1000001033, Box::new(vk_get_image_sparse_memory_requirements));
    map.insert(1000001034, Box::new(vk_get_physical_device_sparse_image_format_properties));
    map.insert(1000001035, Box::new(vk_queue_bind_sparse));
    map.insert(1000001036, Box::new(vk_create_fence));
    map.insert(1000001037, Box::new(vk_destroy_fence));
    map.insert(1000001038, Box::new(vk_reset_fences));
    map.insert(1000001039, Box::new(vk_get_fence_status));
    map.insert(1000001040, Box::new(vk_wait_for_fences));
    map.insert(1000001041, Box::new(vk_create_semaphore));
    map.insert(1000001042, Box::new(vk_destroy_semaphore));
    map.insert(1000001043, Box::new(vk_create_event));
    map.insert(1000001044, Box::new(vk_destroy_event));
    map.insert(1000001045, Box::new(vk_get_event_status));
    map.insert(1000001046, Box::new(vk_set_event));
    map.insert(1000001047, Box::new(vk_reset_event));
    map.insert(1000001048, Box::new(vk_create_query_pool));
    map.insert(1000001049, Box::new(vk_destroy_query_pool));
    map.insert(1000001050, Box::new(vk_get_query_pool_results));
    map.insert(1000001051, Box::new(vk_reset_query_pool));
    map.insert(1000001052, Box::new(vk_create_buffer));
    map.insert(1000001053, Box::new(vk_destroy_buffer));
    map.insert(1000001054, Box::new(vk_create_buffer_view));
    map.insert(1000001055, Box::new(vk_destroy_buffer_view));
    map.insert(1000001056, Box::new(vk_create_image));
    map.insert(1000001057, Box::new(vk_destroy_image));
    map.insert(1000001058, Box::new(vk_get_image_subresource_layout));
    map.insert(1000001059, Box::new(vk_create_image_view));
    map.insert(1000001060, Box::new(vk_destroy_image_view));
    map.insert(1000001061, Box::new(vk_create_shader_module));
    map.insert(1000001062, Box::new(vk_destroy_shader_module));
    map.insert(1000001063, Box::new(vk_create_pipeline_cache));
    map.insert(1000001064, Box::new(vk_destroy_pipeline_cache));
    map.insert(1000001065, Box::new(vk_get_pipeline_cache_data));
    map.insert(1000001066, Box::new(vk_merge_pipeline_caches));
    map.insert(1000001067, Box::new(vk_create_graphics_pipelines));
    map.insert(1000001068, Box::new(vk_create_compute_pipelines));
    map.insert(1000001069, Box::new(vk_get_device_subpass_shading_max_workgroup_size_huawei));
    map.insert(1000001070, Box::new(vk_destroy_pipeline));
    map.insert(1000001071, Box::new(vk_create_pipeline_layout));
    map.insert(1000001072, Box::new(vk_destroy_pipeline_layout));
    map.insert(1000001073, Box::new(vk_create_sampler));
    map.insert(1000001074, Box::new(vk_destroy_sampler));
    map.insert(1000001075, Box::new(vk_create_descriptor_set_layout));
    map.insert(1000001076, Box::new(vk_destroy_descriptor_set_layout));
    map.insert(1000001077, Box::new(vk_create_descriptor_pool));
    map.insert(1000001078, Box::new(vk_destroy_descriptor_pool));
    map.insert(1000001079, Box::new(vk_reset_descriptor_pool));
    map.insert(1000001080, Box::new(vk_allocate_descriptor_sets));
    map.insert(1000001081, Box::new(vk_free_descriptor_sets));
    map.insert(1000001082, Box::new(vk_update_descriptor_sets));
    map.insert(1000001083, Box::new(vk_create_framebuffer));
    map.insert(1000001084, Box::new(vk_destroy_framebuffer));
    map.insert(1000001085, Box::new(vk_create_render_pass));
    map.insert(1000001086, Box::new(vk_destroy_render_pass));
    map.insert(1000001087, Box::new(vk_get_render_area_granularity));
    map.insert(1000001088, Box::new(vk_get_rendering_area_granularity_khr));
    map.insert(1000001089, Box::new(vk_create_command_pool));
    map.insert(1000001090, Box::new(vk_destroy_command_pool));
    map.insert(1000001091, Box::new(vk_reset_command_pool));
    map.insert(1000001092, Box::new(vk_allocate_command_buffers));
    map.insert(1000001093, Box::new(vk_free_command_buffers));
    map.insert(1000001094, Box::new(vk_begin_command_buffer));
    map.insert(1000001095, Box::new(vk_end_command_buffer));
    map.insert(1000001096, Box::new(vk_reset_command_buffer));
    map.insert(1000001097, Box::new(vk_cmd_bind_pipeline));
    map.insert(1000001098, Box::new(vk_cmd_set_attachment_feedback_loop_enable_ext));
    map.insert(1000001099, Box::new(vk_cmd_set_viewport));
    map.insert(1000001100, Box::new(vk_cmd_set_scissor));
    map.insert(1000001101, Box::new(vk_cmd_set_line_width));
    map.insert(1000001102, Box::new(vk_cmd_set_depth_bias));
    map.insert(1000001103, Box::new(vk_cmd_set_blend_constants));
    map.insert(1000001104, Box::new(vk_cmd_set_depth_bounds));
    map.insert(1000001105, Box::new(vk_cmd_set_stencil_compare_mask));
    map.insert(1000001106, Box::new(vk_cmd_set_stencil_write_mask));
    map.insert(1000001107, Box::new(vk_cmd_set_stencil_reference));
    map.insert(1000001108, Box::new(vk_cmd_bind_descriptor_sets));
    map.insert(1000001109, Box::new(vk_cmd_bind_index_buffer));
    map.insert(1000001110, Box::new(vk_cmd_bind_vertex_buffers));
    map.insert(1000001111, Box::new(vk_cmd_draw));
    map.insert(1000001112, Box::new(vk_cmd_draw_indexed));
    map.insert(1000001113, Box::new(vk_cmd_draw_multi_ext));
    map.insert(1000001114, Box::new(vk_cmd_draw_multi_indexed_ext));
    map.insert(1000001115, Box::new(vk_cmd_draw_indirect));
    map.insert(1000001116, Box::new(vk_cmd_draw_indexed_indirect));
    map.insert(1000001117, Box::new(vk_cmd_dispatch));
    map.insert(1000001118, Box::new(vk_cmd_dispatch_indirect));
    map.insert(1000001119, Box::new(vk_cmd_subpass_shading_huawei));
    map.insert(1000001120, Box::new(vk_cmd_draw_cluster_huawei));
    map.insert(1000001121, Box::new(vk_cmd_draw_cluster_indirect_huawei));
    map.insert(1000001122, Box::new(vk_cmd_update_pipeline_indirect_buffer_nv));
    map.insert(1000001123, Box::new(vk_cmd_copy_buffer));
    map.insert(1000001124, Box::new(vk_cmd_copy_image));
    map.insert(1000001125, Box::new(vk_cmd_blit_image));
    map.insert(1000001126, Box::new(vk_cmd_copy_buffer_to_image));
    map.insert(1000001127, Box::new(vk_cmd_copy_image_to_buffer));
    map.insert(1000001128, Box::new(vk_cmd_copy_memory_indirect_nv));
    map.insert(1000001129, Box::new(vk_cmd_copy_memory_to_image_indirect_nv));
    map.insert(1000001130, Box::new(vk_cmd_update_buffer));
    map.insert(1000001131, Box::new(vk_cmd_fill_buffer));
    map.insert(1000001132, Box::new(vk_cmd_clear_color_image));
    map.insert(1000001133, Box::new(vk_cmd_clear_depth_stencil_image));
    map.insert(1000001134, Box::new(vk_cmd_clear_attachments));
    map.insert(1000001135, Box::new(vk_cmd_resolve_image));
    map.insert(1000001136, Box::new(vk_cmd_set_event));
    map.insert(1000001137, Box::new(vk_cmd_reset_event));
    map.insert(1000001138, Box::new(vk_cmd_wait_events));
    map.insert(1000001139, Box::new(vk_cmd_pipeline_barrier));
    map.insert(1000001140, Box::new(vk_cmd_begin_query));
    map.insert(1000001141, Box::new(vk_cmd_end_query));
    map.insert(1000001142, Box::new(vk_cmd_begin_conditional_rendering_ext));
    map.insert(1000001143, Box::new(vk_cmd_end_conditional_rendering_ext));
    map.insert(1000001144, Box::new(vk_cmd_reset_query_pool));
    map.insert(1000001145, Box::new(vk_cmd_write_timestamp));
    map.insert(1000001146, Box::new(vk_cmd_copy_query_pool_results));
    map.insert(1000001147, Box::new(vk_cmd_push_constants));
    map.insert(1000001148, Box::new(vk_cmd_begin_render_pass));
    map.insert(1000001149, Box::new(vk_cmd_next_subpass));
    map.insert(1000001150, Box::new(vk_cmd_end_render_pass));
    map.insert(1000001151, Box::new(vk_cmd_execute_commands));
    map.insert(1000001152, Box::new(vk_create_android_surface_khr));
    map.insert(1000001153, Box::new(vk_get_physical_device_display_properties_khr));
    map.insert(1000001154, Box::new(vk_get_physical_device_display_plane_properties_khr));
    map.insert(1000001155, Box::new(vk_get_display_plane_supported_displays_khr));
    map.insert(1000001156, Box::new(vk_get_display_mode_properties_khr));
    map.insert(1000001157, Box::new(vk_create_display_mode_khr));
    map.insert(1000001158, Box::new(vk_get_display_plane_capabilities_khr));
    map.insert(1000001159, Box::new(vk_create_display_plane_surface_khr));
    map.insert(1000001160, Box::new(vk_create_shared_swapchains_khr));
    map.insert(1000001161, Box::new(vk_destroy_surface_khr));
    map.insert(1000001162, Box::new(vk_get_physical_device_surface_support_khr));
    map.insert(1000001163, Box::new(vk_get_physical_device_surface_capabilities_khr));
    map.insert(1000001164, Box::new(vk_get_physical_device_surface_formats_khr));
    map.insert(1000001165, Box::new(vk_get_physical_device_surface_present_modes_khr));
    map.insert(1000001166, Box::new(vk_create_swapchain_khr));
    map.insert(1000001167, Box::new(vk_destroy_swapchain_khr));
    map.insert(1000001168, Box::new(vk_get_swapchain_images_khr));
    map.insert(1000001169, Box::new(vk_acquire_next_image_khr));
    map.insert(1000001170, Box::new(vk_queue_present_khr));
    map.insert(1000001171, Box::new(vk_create_vi_surface_nn));
    map.insert(1000001172, Box::new(vk_create_wayland_surface_khr));
    map.insert(1000001173, Box::new(vk_get_physical_device_wayland_presentation_support_khr));
    map.insert(1000001174, Box::new(vk_create_win32_surface_khr));
    map.insert(1000001175, Box::new(vk_get_physical_device_win32_presentation_support_khr));
    map.insert(1000001176, Box::new(vk_create_xlib_surface_khr));
    map.insert(1000001177, Box::new(vk_get_physical_device_xlib_presentation_support_khr));
    map.insert(1000001178, Box::new(vk_create_xcb_surface_khr));
    map.insert(1000001179, Box::new(vk_get_physical_device_xcb_presentation_support_khr));
    map.insert(1000001180, Box::new(vk_create_direct_fbsurface_ext));
    map.insert(1000001181, Box::new(vk_get_physical_device_direct_fbpresentation_support_ext));
    map.insert(1000001182, Box::new(vk_create_image_pipe_surface_fuchsia));
    map.insert(1000001183, Box::new(vk_create_stream_descriptor_surface_ggp));
    map.insert(1000001184, Box::new(vk_create_screen_surface_qnx));
    map.insert(1000001185, Box::new(vk_get_physical_device_screen_presentation_support_qnx));
    map.insert(1000001186, Box::new(vk_create_debug_report_callback_ext));
    map.insert(1000001187, Box::new(vk_destroy_debug_report_callback_ext));
    map.insert(1000001188, Box::new(vk_debug_report_message_ext));
    map.insert(1000001189, Box::new(vk_debug_marker_set_object_name_ext));
    map.insert(1000001190, Box::new(vk_debug_marker_set_object_tag_ext));
    map.insert(1000001191, Box::new(vk_cmd_debug_marker_begin_ext));
    map.insert(1000001192, Box::new(vk_cmd_debug_marker_end_ext));
    map.insert(1000001193, Box::new(vk_cmd_debug_marker_insert_ext));
    map.insert(1000001194, Box::new(vk_get_physical_device_external_image_format_properties_nv));
    map.insert(1000001195, Box::new(vk_get_memory_win32_handle_nv));
    map.insert(1000001196, Box::new(vk_cmd_execute_generated_commands_nv));
    map.insert(1000001197, Box::new(vk_cmd_preprocess_generated_commands_nv));
    map.insert(1000001198, Box::new(vk_cmd_bind_pipeline_shader_group_nv));
    map.insert(1000001199, Box::new(vk_get_generated_commands_memory_requirements_nv));
    map.insert(1000001200, Box::new(vk_create_indirect_commands_layout_nv));
    map.insert(1000001201, Box::new(vk_destroy_indirect_commands_layout_nv));
    map.insert(1000001202, Box::new(vk_get_physical_device_features2));
    map.insert(1000001203, Box::new(vk_get_physical_device_properties2));
    map.insert(1000001204, Box::new(vk_get_physical_device_format_properties2));
    map.insert(1000001205, Box::new(vk_get_physical_device_image_format_properties2));
    map.insert(1000001206, Box::new(vk_get_physical_device_queue_family_properties2));
    map.insert(1000001207, Box::new(vk_get_physical_device_memory_properties2));
    map.insert(1000001208, Box::new(vk_get_physical_device_sparse_image_format_properties2));
    map.insert(1000001209, Box::new(vk_cmd_push_descriptor_set_khr));
    map.insert(1000001210, Box::new(vk_trim_command_pool));
    map.insert(1000001211, Box::new(vk_get_physical_device_external_buffer_properties));
    map.insert(1000001212, Box::new(vk_get_memory_win32_handle_khr));
    map.insert(1000001213, Box::new(vk_get_memory_win32_handle_properties_khr));
    map.insert(1000001214, Box::new(vk_get_memory_fd_khr));
    map.insert(1000001215, Box::new(vk_get_memory_fd_properties_khr));
    map.insert(1000001216, Box::new(vk_get_memory_zircon_handle_fuchsia));
    map.insert(1000001217, Box::new(vk_get_memory_zircon_handle_properties_fuchsia));
    map.insert(1000001218, Box::new(vk_get_memory_remote_address_nv));
    map.insert(1000001219, Box::new(vk_get_physical_device_external_semaphore_properties));
    map.insert(1000001220, Box::new(vk_get_semaphore_win32_handle_khr));
    map.insert(1000001221, Box::new(vk_import_semaphore_win32_handle_khr));
    map.insert(1000001222, Box::new(vk_get_semaphore_fd_khr));
    map.insert(1000001223, Box::new(vk_import_semaphore_fd_khr));
    map.insert(1000001224, Box::new(vk_get_semaphore_zircon_handle_fuchsia));
    map.insert(1000001225, Box::new(vk_import_semaphore_zircon_handle_fuchsia));
    map.insert(1000001226, Box::new(vk_get_physical_device_external_fence_properties));
    map.insert(1000001227, Box::new(vk_get_fence_win32_handle_khr));
    map.insert(1000001228, Box::new(vk_import_fence_win32_handle_khr));
    map.insert(1000001229, Box::new(vk_get_fence_fd_khr));
    map.insert(1000001230, Box::new(vk_import_fence_fd_khr));
    map.insert(1000001231, Box::new(vk_release_display_ext));
    map.insert(1000001232, Box::new(vk_acquire_xlib_display_ext));
    map.insert(1000001233, Box::new(vk_get_rand_routput_display_ext));
    map.insert(1000001234, Box::new(vk_acquire_winrt_display_nv));
    map.insert(1000001235, Box::new(vk_get_winrt_display_nv));
    map.insert(1000001236, Box::new(vk_display_power_control_ext));
    map.insert(1000001237, Box::new(vk_register_device_event_ext));
    map.insert(1000001238, Box::new(vk_register_display_event_ext));
    map.insert(1000001239, Box::new(vk_get_swapchain_counter_ext));
    map.insert(1000001240, Box::new(vk_get_physical_device_surface_capabilities2_ext));
    map.insert(1000001241, Box::new(vk_enumerate_physical_device_groups));
    map.insert(1000001242, Box::new(vk_get_device_group_peer_memory_features));
    map.insert(1000001243, Box::new(vk_bind_buffer_memory2));
    map.insert(1000001244, Box::new(vk_bind_image_memory2));
    map.insert(1000001245, Box::new(vk_cmd_set_device_mask));
    map.insert(1000001246, Box::new(vk_get_device_group_present_capabilities_khr));
    map.insert(1000001247, Box::new(vk_get_device_group_surface_present_modes_khr));
    map.insert(1000001248, Box::new(vk_acquire_next_image2_khr));
    map.insert(1000001249, Box::new(vk_cmd_dispatch_base));
    map.insert(1000001250, Box::new(vk_get_physical_device_present_rectangles_khr));
    map.insert(1000001251, Box::new(vk_create_descriptor_update_template));
    map.insert(1000001252, Box::new(vk_destroy_descriptor_update_template));
    map.insert(1000001253, Box::new(vk_update_descriptor_set_with_template));
    map.insert(1000001254, Box::new(vk_cmd_push_descriptor_set_with_template_khr));
    map.insert(1000001255, Box::new(vk_set_hdr_metadata_ext));
    map.insert(1000001256, Box::new(vk_get_swapchain_status_khr));
    map.insert(1000001257, Box::new(vk_get_refresh_cycle_duration_google));
    map.insert(1000001258, Box::new(vk_get_past_presentation_timing_google));
    map.insert(1000001259, Box::new(vk_create_iossurface_mvk));
    map.insert(1000001260, Box::new(vk_create_mac_ossurface_mvk));
    map.insert(1000001261, Box::new(vk_create_metal_surface_ext));
    map.insert(1000001262, Box::new(vk_cmd_set_viewport_wscaling_nv));
    map.insert(1000001263, Box::new(vk_cmd_set_discard_rectangle_ext));
    map.insert(1000001264, Box::new(vk_cmd_set_discard_rectangle_enable_ext));
    map.insert(1000001265, Box::new(vk_cmd_set_discard_rectangle_mode_ext));
    map.insert(1000001266, Box::new(vk_cmd_set_sample_locations_ext));
    map.insert(1000001267, Box::new(vk_get_physical_device_multisample_properties_ext));
    map.insert(1000001268, Box::new(vk_get_physical_device_surface_capabilities2_khr));
    map.insert(1000001269, Box::new(vk_get_physical_device_surface_formats2_khr));
    map.insert(1000001270, Box::new(vk_get_physical_device_display_properties2_khr));
    map.insert(1000001271, Box::new(vk_get_physical_device_display_plane_properties2_khr));
    map.insert(1000001272, Box::new(vk_get_display_mode_properties2_khr));
    map.insert(1000001273, Box::new(vk_get_display_plane_capabilities2_khr));
    map.insert(1000001274, Box::new(vk_get_buffer_memory_requirements2));
    map.insert(1000001275, Box::new(vk_get_image_memory_requirements2));
    map.insert(1000001276, Box::new(vk_get_image_sparse_memory_requirements2));
    map.insert(1000001277, Box::new(vk_get_device_buffer_memory_requirements));
    map.insert(1000001278, Box::new(vk_get_device_image_memory_requirements));
    map.insert(1000001279, Box::new(vk_get_device_image_sparse_memory_requirements));
    map.insert(1000001280, Box::new(vk_create_sampler_ycbcr_conversion));
    map.insert(1000001281, Box::new(vk_destroy_sampler_ycbcr_conversion));
    map.insert(1000001282, Box::new(vk_get_device_queue2));
    map.insert(1000001283, Box::new(vk_create_validation_cache_ext));
    map.insert(1000001284, Box::new(vk_destroy_validation_cache_ext));
    map.insert(1000001285, Box::new(vk_get_validation_cache_data_ext));
    map.insert(1000001286, Box::new(vk_merge_validation_caches_ext));
    map.insert(1000001287, Box::new(vk_get_descriptor_set_layout_support));
    map.insert(1000001288, Box::new(vk_get_swapchain_gralloc_usage_android));
    map.insert(1000001289, Box::new(vk_get_swapchain_gralloc_usage2_android));
    map.insert(1000001290, Box::new(vk_acquire_image_android));
    map.insert(1000001291, Box::new(vk_queue_signal_release_image_android));
    map.insert(1000001292, Box::new(vk_get_shader_info_amd));
    map.insert(1000001293, Box::new(vk_set_local_dimming_amd));
    map.insert(1000001294, Box::new(vk_get_physical_device_calibrateable_time_domains_khr));
    map.insert(1000001295, Box::new(vk_get_calibrated_timestamps_khr));
    map.insert(1000001296, Box::new(vk_set_debug_utils_object_name_ext));
    map.insert(1000001297, Box::new(vk_set_debug_utils_object_tag_ext));
    map.insert(1000001298, Box::new(vk_queue_begin_debug_utils_label_ext));
    map.insert(1000001299, Box::new(vk_queue_end_debug_utils_label_ext));
    map.insert(1000001300, Box::new(vk_queue_insert_debug_utils_label_ext));
    map.insert(1000001301, Box::new(vk_cmd_begin_debug_utils_label_ext));
    map.insert(1000001302, Box::new(vk_cmd_end_debug_utils_label_ext));
    map.insert(1000001303, Box::new(vk_cmd_insert_debug_utils_label_ext));
    map.insert(1000001304, Box::new(vk_create_debug_utils_messenger_ext));
    map.insert(1000001305, Box::new(vk_destroy_debug_utils_messenger_ext));
    map.insert(1000001306, Box::new(vk_submit_debug_utils_message_ext));
    map.insert(1000001307, Box::new(vk_get_memory_host_pointer_properties_ext));
    map.insert(1000001308, Box::new(vk_cmd_write_buffer_marker_amd));
    map.insert(1000001309, Box::new(vk_create_render_pass2));
    map.insert(1000001310, Box::new(vk_cmd_begin_render_pass2));
    map.insert(1000001311, Box::new(vk_cmd_next_subpass2));
    map.insert(1000001312, Box::new(vk_cmd_end_render_pass2));
    map.insert(1000001313, Box::new(vk_get_semaphore_counter_value));
    map.insert(1000001314, Box::new(vk_wait_semaphores));
    map.insert(1000001315, Box::new(vk_signal_semaphore));
    map.insert(1000001316, Box::new(vk_get_android_hardware_buffer_properties_android));
    map.insert(1000001317, Box::new(vk_get_memory_android_hardware_buffer_android));
    map.insert(1000001318, Box::new(vk_cmd_draw_indirect_count));
    map.insert(1000001319, Box::new(vk_cmd_draw_indexed_indirect_count));
    map.insert(1000001320, Box::new(vk_cmd_set_checkpoint_nv));
    map.insert(1000001321, Box::new(vk_get_queue_checkpoint_data_nv));
    map.insert(1000001322, Box::new(vk_cmd_bind_transform_feedback_buffers_ext));
    map.insert(1000001323, Box::new(vk_cmd_begin_transform_feedback_ext));
    map.insert(1000001324, Box::new(vk_cmd_end_transform_feedback_ext));
    map.insert(1000001325, Box::new(vk_cmd_begin_query_indexed_ext));
    map.insert(1000001326, Box::new(vk_cmd_end_query_indexed_ext));
    map.insert(1000001327, Box::new(vk_cmd_draw_indirect_byte_count_ext));
    map.insert(1000001328, Box::new(vk_cmd_set_exclusive_scissor_nv));
    map.insert(1000001329, Box::new(vk_cmd_set_exclusive_scissor_enable_nv));
    map.insert(1000001330, Box::new(vk_cmd_bind_shading_rate_image_nv));
    map.insert(1000001331, Box::new(vk_cmd_set_viewport_shading_rate_palette_nv));
    map.insert(1000001332, Box::new(vk_cmd_set_coarse_sample_order_nv));
    map.insert(1000001333, Box::new(vk_cmd_draw_mesh_tasks_nv));
    map.insert(1000001334, Box::new(vk_cmd_draw_mesh_tasks_indirect_nv));
    map.insert(1000001335, Box::new(vk_cmd_draw_mesh_tasks_indirect_count_nv));
    map.insert(1000001336, Box::new(vk_cmd_draw_mesh_tasks_ext));
    map.insert(1000001337, Box::new(vk_cmd_draw_mesh_tasks_indirect_ext));
    map.insert(1000001338, Box::new(vk_cmd_draw_mesh_tasks_indirect_count_ext));
    map.insert(1000001339, Box::new(vk_compile_deferred_nv));
    map.insert(1000001340, Box::new(vk_create_acceleration_structure_nv));
    map.insert(1000001341, Box::new(vk_cmd_bind_invocation_mask_huawei));
    map.insert(1000001342, Box::new(vk_destroy_acceleration_structure_khr));
    map.insert(1000001343, Box::new(vk_destroy_acceleration_structure_nv));
    map.insert(1000001344, Box::new(vk_get_acceleration_structure_memory_requirements_nv));
    map.insert(1000001345, Box::new(vk_bind_acceleration_structure_memory_nv));
    map.insert(1000001346, Box::new(vk_cmd_copy_acceleration_structure_nv));
    map.insert(1000001347, Box::new(vk_cmd_copy_acceleration_structure_khr));
    map.insert(1000001348, Box::new(vk_copy_acceleration_structure_khr));
    map.insert(1000001349, Box::new(vk_cmd_copy_acceleration_structure_to_memory_khr));
    map.insert(1000001350, Box::new(vk_copy_acceleration_structure_to_memory_khr));
    map.insert(1000001351, Box::new(vk_cmd_copy_memory_to_acceleration_structure_khr));
    map.insert(1000001352, Box::new(vk_copy_memory_to_acceleration_structure_khr));
    map.insert(1000001353, Box::new(vk_cmd_write_acceleration_structures_properties_khr));
    map.insert(1000001354, Box::new(vk_cmd_write_acceleration_structures_properties_nv));
    map.insert(1000001355, Box::new(vk_cmd_build_acceleration_structure_nv));
    map.insert(1000001356, Box::new(vk_write_acceleration_structures_properties_khr));
    map.insert(1000001357, Box::new(vk_cmd_trace_rays_khr));
    map.insert(1000001358, Box::new(vk_cmd_trace_rays_nv));
    map.insert(1000001359, Box::new(vk_get_ray_tracing_shader_group_handles_khr));
    map.insert(1000001360, Box::new(vk_get_ray_tracing_capture_replay_shader_group_handles_khr));
    map.insert(1000001361, Box::new(vk_get_acceleration_structure_handle_nv));
    map.insert(1000001362, Box::new(vk_create_ray_tracing_pipelines_nv));
    map.insert(1000001363, Box::new(vk_create_ray_tracing_pipelines_khr));
    map.insert(1000001364, Box::new(vk_get_physical_device_cooperative_matrix_properties_nv));
    map.insert(1000001365, Box::new(vk_cmd_trace_rays_indirect_khr));
    map.insert(1000001366, Box::new(vk_cmd_trace_rays_indirect2_khr));
    map.insert(1000001367, Box::new(vk_get_device_acceleration_structure_compatibility_khr));
    map.insert(1000001368, Box::new(vk_get_ray_tracing_shader_group_stack_size_khr));
    map.insert(1000001369, Box::new(vk_cmd_set_ray_tracing_pipeline_stack_size_khr));
    map.insert(1000001370, Box::new(vk_get_image_view_handle_nvx));
    map.insert(1000001371, Box::new(vk_get_image_view_address_nvx));
    map.insert(1000001372, Box::new(vk_get_physical_device_surface_present_modes2_ext));
    map.insert(1000001373, Box::new(vk_get_device_group_surface_present_modes2_ext));
    map.insert(1000001374, Box::new(vk_acquire_full_screen_exclusive_mode_ext));
    map.insert(1000001375, Box::new(vk_release_full_screen_exclusive_mode_ext));
    map.insert(1000001376, Box::new(vk_enumerate_physical_device_queue_family_performance_query_counters_khr));
    map.insert(1000001377, Box::new(vk_get_physical_device_queue_family_performance_query_passes_khr));
    map.insert(1000001378, Box::new(vk_acquire_profiling_lock_khr));
    map.insert(1000001379, Box::new(vk_release_profiling_lock_khr));
    map.insert(1000001380, Box::new(vk_get_image_drm_format_modifier_properties_ext));
    map.insert(1000001381, Box::new(vk_get_buffer_opaque_capture_address));
    map.insert(1000001382, Box::new(vk_get_buffer_device_address));
    map.insert(1000001383, Box::new(vk_create_headless_surface_ext));
    map.insert(1000001384, Box::new(vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv));
    map.insert(1000001385, Box::new(vk_initialize_performance_api_intel));
    map.insert(1000001386, Box::new(vk_uninitialize_performance_api_intel));
    map.insert(1000001387, Box::new(vk_cmd_set_performance_marker_intel));
    map.insert(1000001388, Box::new(vk_cmd_set_performance_stream_marker_intel));
    map.insert(1000001389, Box::new(vk_cmd_set_performance_override_intel));
    map.insert(1000001390, Box::new(vk_acquire_performance_configuration_intel));
    map.insert(1000001391, Box::new(vk_release_performance_configuration_intel));
    map.insert(1000001392, Box::new(vk_queue_set_performance_configuration_intel));
    map.insert(1000001393, Box::new(vk_get_performance_parameter_intel));
    map.insert(1000001394, Box::new(vk_get_device_memory_opaque_capture_address));
    map.insert(1000001395, Box::new(vk_get_pipeline_executable_properties_khr));
    map.insert(1000001396, Box::new(vk_get_pipeline_executable_statistics_khr));
    map.insert(1000001397, Box::new(vk_get_pipeline_executable_internal_representations_khr));
    map.insert(1000001398, Box::new(vk_cmd_set_line_stipple_khr));
    map.insert(1000001399, Box::new(vk_get_physical_device_tool_properties));
    map.insert(1000001400, Box::new(vk_create_acceleration_structure_khr));
    map.insert(1000001401, Box::new(vk_cmd_build_acceleration_structures_khr));
    map.insert(1000001402, Box::new(vk_cmd_build_acceleration_structures_indirect_khr));
    map.insert(1000001403, Box::new(vk_build_acceleration_structures_khr));
    map.insert(1000001404, Box::new(vk_get_acceleration_structure_device_address_khr));
    map.insert(1000001405, Box::new(vk_create_deferred_operation_khr));
    map.insert(1000001406, Box::new(vk_destroy_deferred_operation_khr));
    map.insert(1000001407, Box::new(vk_get_deferred_operation_max_concurrency_khr));
    map.insert(1000001408, Box::new(vk_get_deferred_operation_result_khr));
    map.insert(1000001409, Box::new(vk_deferred_operation_join_khr));
    map.insert(1000001410, Box::new(vk_get_pipeline_indirect_memory_requirements_nv));
    map.insert(1000001411, Box::new(vk_get_pipeline_indirect_device_address_nv));
    map.insert(1000001412, Box::new(vk_cmd_set_cull_mode));
    map.insert(1000001413, Box::new(vk_cmd_set_front_face));
    map.insert(1000001414, Box::new(vk_cmd_set_primitive_topology));
    map.insert(1000001415, Box::new(vk_cmd_set_viewport_with_count));
    map.insert(1000001416, Box::new(vk_cmd_set_scissor_with_count));
    map.insert(1000001417, Box::new(vk_cmd_bind_index_buffer2_khr));
    map.insert(1000001418, Box::new(vk_cmd_bind_vertex_buffers2));
    map.insert(1000001419, Box::new(vk_cmd_set_depth_test_enable));
    map.insert(1000001420, Box::new(vk_cmd_set_depth_write_enable));
    map.insert(1000001421, Box::new(vk_cmd_set_depth_compare_op));
    map.insert(1000001422, Box::new(vk_cmd_set_depth_bounds_test_enable));
    map.insert(1000001423, Box::new(vk_cmd_set_stencil_test_enable));
    map.insert(1000001424, Box::new(vk_cmd_set_stencil_op));
    map.insert(1000001425, Box::new(vk_cmd_set_patch_control_points_ext));
    map.insert(1000001426, Box::new(vk_cmd_set_rasterizer_discard_enable));
    map.insert(1000001427, Box::new(vk_cmd_set_depth_bias_enable));
    map.insert(1000001428, Box::new(vk_cmd_set_logic_op_ext));
    map.insert(1000001429, Box::new(vk_cmd_set_primitive_restart_enable));
    map.insert(1000001430, Box::new(vk_cmd_set_tessellation_domain_origin_ext));
    map.insert(1000001431, Box::new(vk_cmd_set_depth_clamp_enable_ext));
    map.insert(1000001432, Box::new(vk_cmd_set_polygon_mode_ext));
    map.insert(1000001433, Box::new(vk_cmd_set_rasterization_samples_ext));
    map.insert(1000001434, Box::new(vk_cmd_set_sample_mask_ext));
    map.insert(1000001435, Box::new(vk_cmd_set_alpha_to_coverage_enable_ext));
    map.insert(1000001436, Box::new(vk_cmd_set_alpha_to_one_enable_ext));
    map.insert(1000001437, Box::new(vk_cmd_set_logic_op_enable_ext));
    map.insert(1000001438, Box::new(vk_cmd_set_color_blend_enable_ext));
    map.insert(1000001439, Box::new(vk_cmd_set_color_blend_equation_ext));
    map.insert(1000001440, Box::new(vk_cmd_set_color_write_mask_ext));
    map.insert(1000001441, Box::new(vk_cmd_set_rasterization_stream_ext));
    map.insert(1000001442, Box::new(vk_cmd_set_conservative_rasterization_mode_ext));
    map.insert(1000001443, Box::new(vk_cmd_set_extra_primitive_overestimation_size_ext));
    map.insert(1000001444, Box::new(vk_cmd_set_depth_clip_enable_ext));
    map.insert(1000001445, Box::new(vk_cmd_set_sample_locations_enable_ext));
    map.insert(1000001446, Box::new(vk_cmd_set_color_blend_advanced_ext));
    map.insert(1000001447, Box::new(vk_cmd_set_provoking_vertex_mode_ext));
    map.insert(1000001448, Box::new(vk_cmd_set_line_rasterization_mode_ext));
    map.insert(1000001449, Box::new(vk_cmd_set_line_stipple_enable_ext));
    map.insert(1000001450, Box::new(vk_cmd_set_depth_clip_negative_one_to_one_ext));
    map.insert(1000001451, Box::new(vk_cmd_set_viewport_wscaling_enable_nv));
    map.insert(1000001452, Box::new(vk_cmd_set_viewport_swizzle_nv));
    map.insert(1000001453, Box::new(vk_cmd_set_coverage_to_color_enable_nv));
    map.insert(1000001454, Box::new(vk_cmd_set_coverage_to_color_location_nv));
    map.insert(1000001455, Box::new(vk_cmd_set_coverage_modulation_mode_nv));
    map.insert(1000001456, Box::new(vk_cmd_set_coverage_modulation_table_enable_nv));
    map.insert(1000001457, Box::new(vk_cmd_set_coverage_modulation_table_nv));
    map.insert(1000001458, Box::new(vk_cmd_set_shading_rate_image_enable_nv));
    map.insert(1000001459, Box::new(vk_cmd_set_coverage_reduction_mode_nv));
    map.insert(1000001460, Box::new(vk_cmd_set_representative_fragment_test_enable_nv));
    map.insert(1000001461, Box::new(vk_create_private_data_slot));
    map.insert(1000001462, Box::new(vk_destroy_private_data_slot));
    map.insert(1000001463, Box::new(vk_set_private_data));
    map.insert(1000001464, Box::new(vk_get_private_data));
    map.insert(1000001465, Box::new(vk_cmd_copy_buffer2));
    map.insert(1000001466, Box::new(vk_cmd_copy_image2));
    map.insert(1000001467, Box::new(vk_cmd_blit_image2));
    map.insert(1000001468, Box::new(vk_cmd_copy_buffer_to_image2));
    map.insert(1000001469, Box::new(vk_cmd_copy_image_to_buffer2));
    map.insert(1000001470, Box::new(vk_cmd_resolve_image2));
    map.insert(1000001471, Box::new(vk_cmd_set_fragment_shading_rate_khr));
    map.insert(1000001472, Box::new(vk_get_physical_device_fragment_shading_rates_khr));
    map.insert(1000001473, Box::new(vk_cmd_set_fragment_shading_rate_enum_nv));
    map.insert(1000001474, Box::new(vk_get_acceleration_structure_build_sizes_khr));
    map.insert(1000001475, Box::new(vk_cmd_set_vertex_input_ext));
    map.insert(1000001476, Box::new(vk_cmd_set_color_write_enable_ext));
    map.insert(1000001477, Box::new(vk_cmd_set_event2));
    map.insert(1000001478, Box::new(vk_cmd_reset_event2));
    map.insert(1000001479, Box::new(vk_cmd_wait_events2));
    map.insert(1000001480, Box::new(vk_cmd_pipeline_barrier2));
    map.insert(1000001481, Box::new(vk_queue_submit2));
    map.insert(1000001482, Box::new(vk_cmd_write_timestamp2));
    map.insert(1000001483, Box::new(vk_cmd_write_buffer_marker2_amd));
    map.insert(1000001484, Box::new(vk_get_queue_checkpoint_data2_nv));
    map.insert(1000001485, Box::new(vk_copy_memory_to_image_ext));
    map.insert(1000001486, Box::new(vk_copy_image_to_memory_ext));
    map.insert(1000001487, Box::new(vk_copy_image_to_image_ext));
    map.insert(1000001488, Box::new(vk_transition_image_layout_ext));
    map.insert(1000001489, Box::new(vk_get_physical_device_video_capabilities_khr));
    map.insert(1000001490, Box::new(vk_get_physical_device_video_format_properties_khr));
    map.insert(1000001491, Box::new(vk_get_physical_device_video_encode_quality_level_properties_khr));
    map.insert(1000001492, Box::new(vk_create_video_session_khr));
    map.insert(1000001493, Box::new(vk_destroy_video_session_khr));
    map.insert(1000001494, Box::new(vk_create_video_session_parameters_khr));
    map.insert(1000001495, Box::new(vk_update_video_session_parameters_khr));
    map.insert(1000001496, Box::new(vk_get_encoded_video_session_parameters_khr));
    map.insert(1000001497, Box::new(vk_destroy_video_session_parameters_khr));
    map.insert(1000001498, Box::new(vk_get_video_session_memory_requirements_khr));
    map.insert(1000001499, Box::new(vk_bind_video_session_memory_khr));
    map.insert(1000001500, Box::new(vk_cmd_decode_video_khr));
    map.insert(1000001501, Box::new(vk_cmd_begin_video_coding_khr));
    map.insert(1000001502, Box::new(vk_cmd_control_video_coding_khr));
    map.insert(1000001503, Box::new(vk_cmd_end_video_coding_khr));
    map.insert(1000001504, Box::new(vk_cmd_encode_video_khr));
    map.insert(1000001505, Box::new(vk_cmd_decompress_memory_nv));
    map.insert(1000001506, Box::new(vk_cmd_decompress_memory_indirect_count_nv));
    map.insert(1000001507, Box::new(vk_create_cu_module_nvx));
    map.insert(1000001508, Box::new(vk_create_cu_function_nvx));
    map.insert(1000001509, Box::new(vk_destroy_cu_module_nvx));
    map.insert(1000001510, Box::new(vk_destroy_cu_function_nvx));
    map.insert(1000001511, Box::new(vk_cmd_cu_launch_kernel_nvx));
    map.insert(1000001512, Box::new(vk_get_descriptor_set_layout_size_ext));
    map.insert(1000001513, Box::new(vk_get_descriptor_set_layout_binding_offset_ext));
    map.insert(1000001514, Box::new(vk_get_descriptor_ext));
    map.insert(1000001515, Box::new(vk_cmd_bind_descriptor_buffers_ext));
    map.insert(1000001516, Box::new(vk_cmd_set_descriptor_buffer_offsets_ext));
    map.insert(1000001517, Box::new(vk_cmd_bind_descriptor_buffer_embedded_samplers_ext));
    map.insert(1000001518, Box::new(vk_get_buffer_opaque_capture_descriptor_data_ext));
    map.insert(1000001519, Box::new(vk_get_image_opaque_capture_descriptor_data_ext));
    map.insert(1000001520, Box::new(vk_get_image_view_opaque_capture_descriptor_data_ext));
    map.insert(1000001521, Box::new(vk_get_sampler_opaque_capture_descriptor_data_ext));
    map.insert(1000001522, Box::new(vk_get_acceleration_structure_opaque_capture_descriptor_data_ext));
    map.insert(1000001523, Box::new(vk_set_device_memory_priority_ext));
    map.insert(1000001524, Box::new(vk_acquire_drm_display_ext));
    map.insert(1000001525, Box::new(vk_get_drm_display_ext));
    map.insert(1000001526, Box::new(vk_wait_for_present_khr));
    map.insert(1000001527, Box::new(vk_create_buffer_collection_fuchsia));
    map.insert(1000001528, Box::new(vk_set_buffer_collection_buffer_constraints_fuchsia));
    map.insert(1000001529, Box::new(vk_set_buffer_collection_image_constraints_fuchsia));
    map.insert(1000001530, Box::new(vk_destroy_buffer_collection_fuchsia));
    map.insert(1000001531, Box::new(vk_get_buffer_collection_properties_fuchsia));
    map.insert(1000001532, Box::new(vk_create_cuda_module_nv));
    map.insert(1000001533, Box::new(vk_get_cuda_module_cache_nv));
    map.insert(1000001534, Box::new(vk_create_cuda_function_nv));
    map.insert(1000001535, Box::new(vk_destroy_cuda_module_nv));
    map.insert(1000001536, Box::new(vk_destroy_cuda_function_nv));
    map.insert(1000001537, Box::new(vk_cmd_cuda_launch_kernel_nv));
    map.insert(1000001538, Box::new(vk_cmd_begin_rendering));
    map.insert(1000001539, Box::new(vk_cmd_end_rendering));
    map.insert(1000001540, Box::new(vk_get_descriptor_set_layout_host_mapping_info_valve));
    map.insert(1000001541, Box::new(vk_get_descriptor_set_host_mapping_valve));
    map.insert(1000001542, Box::new(vk_create_micromap_ext));
    map.insert(1000001543, Box::new(vk_cmd_build_micromaps_ext));
    map.insert(1000001544, Box::new(vk_build_micromaps_ext));
    map.insert(1000001545, Box::new(vk_destroy_micromap_ext));
    map.insert(1000001546, Box::new(vk_cmd_copy_micromap_ext));
    map.insert(1000001547, Box::new(vk_copy_micromap_ext));
    map.insert(1000001548, Box::new(vk_cmd_copy_micromap_to_memory_ext));
    map.insert(1000001549, Box::new(vk_copy_micromap_to_memory_ext));
    map.insert(1000001550, Box::new(vk_cmd_copy_memory_to_micromap_ext));
    map.insert(1000001551, Box::new(vk_copy_memory_to_micromap_ext));
    map.insert(1000001552, Box::new(vk_cmd_write_micromaps_properties_ext));
    map.insert(1000001553, Box::new(vk_write_micromaps_properties_ext));
    map.insert(1000001554, Box::new(vk_get_device_micromap_compatibility_ext));
    map.insert(1000001555, Box::new(vk_get_micromap_build_sizes_ext));
    map.insert(1000001556, Box::new(vk_get_shader_module_identifier_ext));
    map.insert(1000001557, Box::new(vk_get_shader_module_create_info_identifier_ext));
    map.insert(1000001558, Box::new(vk_get_image_subresource_layout2_khr));
    map.insert(1000001559, Box::new(vk_get_pipeline_properties_ext));
    map.insert(1000001560, Box::new(vk_export_metal_objects_ext));
    map.insert(1000001561, Box::new(vk_get_framebuffer_tile_properties_qcom));
    map.insert(1000001562, Box::new(vk_get_dynamic_rendering_tile_properties_qcom));
    map.insert(1000001563, Box::new(vk_get_physical_device_optical_flow_image_formats_nv));
    map.insert(1000001564, Box::new(vk_create_optical_flow_session_nv));
    map.insert(1000001565, Box::new(vk_destroy_optical_flow_session_nv));
    map.insert(1000001566, Box::new(vk_bind_optical_flow_session_image_nv));
    map.insert(1000001567, Box::new(vk_cmd_optical_flow_execute_nv));
    map.insert(1000001568, Box::new(vk_get_device_fault_info_ext));
    map.insert(1000001569, Box::new(vk_cmd_set_depth_bias2_ext));
    map.insert(1000001570, Box::new(vk_release_swapchain_images_ext));
    map.insert(1000001571, Box::new(vk_get_device_image_subresource_layout_khr));
    map.insert(1000001572, Box::new(vk_map_memory2_khr));
    map.insert(1000001573, Box::new(vk_unmap_memory2_khr));
    map.insert(1000001574, Box::new(vk_create_shaders_ext));
    map.insert(1000001575, Box::new(vk_destroy_shader_ext));
    map.insert(1000001576, Box::new(vk_get_shader_binary_data_ext));
    map.insert(1000001577, Box::new(vk_cmd_bind_shaders_ext));
    map.insert(1000001578, Box::new(vk_get_screen_buffer_properties_qnx));
    map.insert(1000001579, Box::new(vk_get_physical_device_cooperative_matrix_properties_khr));
    map.insert(1000001580, Box::new(vk_get_execution_graph_pipeline_scratch_size_amdx));
    map.insert(1000001581, Box::new(vk_get_execution_graph_pipeline_node_index_amdx));
    map.insert(1000001582, Box::new(vk_create_execution_graph_pipelines_amdx));
    map.insert(1000001583, Box::new(vk_cmd_initialize_graph_scratch_memory_amdx));
    map.insert(1000001584, Box::new(vk_cmd_dispatch_graph_amdx));
    map.insert(1000001585, Box::new(vk_cmd_dispatch_graph_indirect_amdx));
    map.insert(1000001586, Box::new(vk_cmd_dispatch_graph_indirect_count_amdx));
    map.insert(1000001587, Box::new(vk_cmd_bind_descriptor_sets2_khr));
    map.insert(1000001588, Box::new(vk_cmd_push_constants2_khr));
    map.insert(1000001589, Box::new(vk_cmd_push_descriptor_set2_khr));
    map.insert(1000001590, Box::new(vk_cmd_push_descriptor_set_with_template2_khr));
    map.insert(1000001591, Box::new(vk_cmd_set_descriptor_buffer_offsets2_ext));
    map.insert(1000001592, Box::new(vk_cmd_bind_descriptor_buffer_embedded_samplers2_ext));
    map.insert(1000001593, Box::new(vk_set_latency_sleep_mode_nv));
    map.insert(1000001594, Box::new(vk_latency_sleep_nv));
    map.insert(1000001595, Box::new(vk_set_latency_marker_nv));
    map.insert(1000001596, Box::new(vk_get_latency_timings_nv));
    map.insert(1000001597, Box::new(vk_queue_notify_out_of_band_nv));
    map.insert(1000001598, Box::new(vk_cmd_set_rendering_attachment_locations_khr));
    map.insert(1000001599, Box::new(vk_cmd_set_rendering_input_attachment_indices_khr));
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateInstance.html>"]
fn vk_create_instance(mut packet: Packet) {
    let p_create_info: *const VkInstanceCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_instance: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateInstance({p_create_info:?}, {p_allocator:?}, {p_instance:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_instance)(
            p_create_info,
            p_allocator,
            p_instance,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_instance);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyInstance.html>"]
fn vk_destroy_instance(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyInstance({instance:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_instance)(
            instance,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDevices.html>"]
fn vk_enumerate_physical_devices(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let (mut p_physical_device_count, p_physical_devices) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkEnumeratePhysicalDevices({instance:?}, {p_physical_device_count:?}, {p_physical_devices:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_physical_devices)(
            instance,
            &mut p_physical_device_count,
            p_physical_devices,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_physical_device_count, p_physical_devices);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceProcAddr.html>"]
fn vk_get_device_proc_addr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_name: *const c_char = packet.read_nullable_raw_ptr();
    trace!("called vkGetDeviceProcAddr({device:?}, {p_name:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_proc_addr)(
            device,
            p_name,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetInstanceProcAddr.html>"]
fn vk_get_instance_proc_addr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_name: *const c_char = packet.read_nullable_raw_ptr();
    trace!("called vkGetInstanceProcAddr({instance:?}, {p_name:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_instance_proc_addr)(
            instance,
            p_name,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties.html>"]
fn vk_get_physical_device_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_properties: *mut VkPhysicalDeviceProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceProperties({physical_device:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_properties)(
            physical_device,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html>"]
fn vk_get_physical_device_queue_family_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_queue_family_property_count, p_queue_family_properties) = packet.read_and_allocate_vk_array_count::<VkQueueFamilyProperties>();
    trace!("called vkGetPhysicalDeviceQueueFamilyProperties({physical_device:?}, {p_queue_family_property_count:?}, {p_queue_family_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_queue_family_properties)(
            physical_device,
            &mut p_queue_family_property_count,
            p_queue_family_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_queue_family_property_count, p_queue_family_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html>"]
fn vk_get_physical_device_memory_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_memory_properties: *mut VkPhysicalDeviceMemoryProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceMemoryProperties({physical_device:?}, {p_memory_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_memory_properties)(
            physical_device,
            p_memory_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures.html>"]
fn vk_get_physical_device_features(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_features: *mut VkPhysicalDeviceFeatures = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceFeatures({physical_device:?}, {p_features:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_features)(
            physical_device,
            p_features,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_features);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html>"]
fn vk_get_physical_device_format_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let p_format_properties: *mut VkFormatProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceFormatProperties({physical_device:?}, {format:?}, {p_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_format_properties)(
            physical_device,
            format,
            p_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html>"]
fn vk_get_physical_device_image_format_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let type_: NonDisposableHandle = packet.read();
    let tiling: NonDisposableHandle = packet.read();
    let usage: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    let p_image_format_properties: *mut VkImageFormatProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceImageFormatProperties({physical_device:?}, {format:?}, {type_:?}, {tiling:?}, {usage:?}, {flags:?}, {p_image_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_image_format_properties)(
            physical_device,
            format,
            type_,
            tiling,
            usage,
            flags,
            p_image_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_image_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDevice.html>"]
fn vk_create_device(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDeviceCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_device: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDevice({physical_device:?}, {p_create_info:?}, {p_allocator:?}, {p_device:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_device)(
            physical_device,
            p_create_info,
            p_allocator,
            p_device,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_device);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDevice.html>"]
fn vk_destroy_device(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDevice({device:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_device)(
            device,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceVersion.html>"]
fn vk_enumerate_instance_version(mut packet: Packet) {
    let p_api_version: *mut u32 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkEnumerateInstanceVersion({p_api_version:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_instance_version)(
            p_api_version,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_api_version);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceLayerProperties.html>"]
fn vk_enumerate_instance_layer_properties(mut packet: Packet) {
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkLayerProperties>();
    trace!("called vkEnumerateInstanceLayerProperties({p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_instance_layer_properties)(
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateInstanceExtensionProperties.html>"]
fn vk_enumerate_instance_extension_properties(mut packet: Packet) {
    let p_layer_name: *const c_char = packet.read_nullable_raw_ptr();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkExtensionProperties>();
    trace!("called vkEnumerateInstanceExtensionProperties({p_layer_name:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_instance_extension_properties)(
            p_layer_name,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceLayerProperties.html>"]
fn vk_enumerate_device_layer_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkLayerProperties>();
    trace!("called vkEnumerateDeviceLayerProperties({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_device_layer_properties)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumerateDeviceExtensionProperties.html>"]
fn vk_enumerate_device_extension_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_layer_name: *const c_char = packet.read_nullable_raw_ptr();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkExtensionProperties>();
    trace!("called vkEnumerateDeviceExtensionProperties({physical_device:?}, {p_layer_name:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_device_extension_properties)(
            physical_device,
            p_layer_name,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue.html>"]
fn vk_get_device_queue(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let queue_index: u32 = packet.read();
    let p_queue: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceQueue({device:?}, {queue_family_index:?}, {queue_index:?}, {p_queue:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_queue)(
            device,
            queue_family_index,
            queue_index,
            p_queue,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_queue);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit.html>"]
fn vk_queue_submit(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let submit_count: u32 = packet.read();
    let p_submits: *const VkSubmitInfo = packet.read_nullable_raw_ptr();
    let fence: NonDisposableHandle = packet.read();
    trace!("called vkQueueSubmit({queue:?}, {submit_count:?}, {p_submits:?}, {fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_submit)(
            queue,
            submit_count,
            p_submits,
            fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueWaitIdle.html>"]
fn vk_queue_wait_idle(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    trace!("called vkQueueWaitIdle({queue:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_wait_idle)(
            queue,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeviceWaitIdle.html>"]
fn vk_device_wait_idle(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    trace!("called vkDeviceWaitIdle({device:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_device_wait_idle)(
            device,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateMemory.html>"]
fn vk_allocate_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_allocate_info: *const VkMemoryAllocateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_memory: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAllocateMemory({device:?}, {p_allocate_info:?}, {p_allocator:?}, {p_memory:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_allocate_memory)(
            device,
            p_allocate_info,
            p_allocator,
            p_memory,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkFreeMemory.html>"]
fn vk_free_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkFreeMemory({device:?}, {memory:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_free_memory)(
            device,
            memory,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMapMemory.html>"]
fn vk_map_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let size: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    let pp_data: *mut *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkMapMemory({device:?}, {memory:?}, {offset:?}, {size:?}, {flags:?}, {pp_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_map_memory)(
            device,
            memory,
            offset,
            size,
            flags,
            pp_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(pp_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory.html>"]
fn vk_unmap_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    trace!("called vkUnmapMemory({device:?}, {memory:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_unmap_memory)(
            device,
            memory,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkFlushMappedMemoryRanges.html>"]
fn vk_flush_mapped_memory_ranges(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory_range_count: u32 = packet.read();
    let p_memory_ranges: *const VkMappedMemoryRange = packet.read_nullable_raw_ptr();
    trace!("called vkFlushMappedMemoryRanges({device:?}, {memory_range_count:?}, {p_memory_ranges:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_flush_mapped_memory_ranges)(
            device,
            memory_range_count,
            p_memory_ranges,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkInvalidateMappedMemoryRanges.html>"]
fn vk_invalidate_mapped_memory_ranges(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory_range_count: u32 = packet.read();
    let p_memory_ranges: *const VkMappedMemoryRange = packet.read_nullable_raw_ptr();
    trace!("called vkInvalidateMappedMemoryRanges({device:?}, {memory_range_count:?}, {p_memory_ranges:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_invalidate_mapped_memory_ranges)(
            device,
            memory_range_count,
            p_memory_ranges,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryCommitment.html>"]
fn vk_get_device_memory_commitment(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let p_committed_memory_in_bytes: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceMemoryCommitment({device:?}, {memory:?}, {p_committed_memory_in_bytes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_memory_commitment)(
            device,
            memory,
            p_committed_memory_in_bytes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_committed_memory_in_bytes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements.html>"]
fn vk_get_buffer_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let p_memory_requirements: *mut VkMemoryRequirements = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetBufferMemoryRequirements({device:?}, {buffer:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_memory_requirements)(
            device,
            buffer,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory.html>"]
fn vk_bind_buffer_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let memory_offset: NonDisposableHandle = packet.read();
    trace!("called vkBindBufferMemory({device:?}, {buffer:?}, {memory:?}, {memory_offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_buffer_memory)(
            device,
            buffer,
            memory,
            memory_offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements.html>"]
fn vk_get_image_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let p_memory_requirements: *mut VkMemoryRequirements = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageMemoryRequirements({device:?}, {image:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_memory_requirements)(
            device,
            image,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory.html>"]
fn vk_bind_image_memory(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let memory_offset: NonDisposableHandle = packet.read();
    trace!("called vkBindImageMemory({device:?}, {image:?}, {memory:?}, {memory_offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_image_memory)(
            device,
            image,
            memory,
            memory_offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements.html>"]
fn vk_get_image_sparse_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let (mut p_sparse_memory_requirement_count, p_sparse_memory_requirements) = packet.read_and_allocate_vk_array_count::<VkSparseImageMemoryRequirements>();
    trace!("called vkGetImageSparseMemoryRequirements({device:?}, {image:?}, {p_sparse_memory_requirement_count:?}, {p_sparse_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_sparse_memory_requirements)(
            device,
            image,
            &mut p_sparse_memory_requirement_count,
            p_sparse_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html>"]
fn vk_get_physical_device_sparse_image_format_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let type_: NonDisposableHandle = packet.read();
    let samples: vk::SampleCountFlags = packet.read();
    let usage: NonDisposableHandle = packet.read();
    let tiling: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkSparseImageFormatProperties>();
    trace!("called vkGetPhysicalDeviceSparseImageFormatProperties({physical_device:?}, {format:?}, {type_:?}, {samples:?}, {usage:?}, {tiling:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_sparse_image_format_properties)(
            physical_device,
            format,
            type_,
            samples,
            usage,
            tiling,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueBindSparse.html>"]
fn vk_queue_bind_sparse(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let bind_info_count: u32 = packet.read();
    let p_bind_info: *const VkBindSparseInfo = packet.read_nullable_raw_ptr();
    let fence: NonDisposableHandle = packet.read();
    trace!("called vkQueueBindSparse({queue:?}, {bind_info_count:?}, {p_bind_info:?}, {fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_bind_sparse)(
            queue,
            bind_info_count,
            p_bind_info,
            fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateFence.html>"]
fn vk_create_fence(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkFenceCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_fence: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateFence({device:?}, {p_create_info:?}, {p_allocator:?}, {p_fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_fence)(
            device,
            p_create_info,
            p_allocator,
            p_fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fence);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyFence.html>"]
fn vk_destroy_fence(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let fence: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyFence({device:?}, {fence:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_fence)(
            device,
            fence,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetFences.html>"]
fn vk_reset_fences(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let fence_count: u32 = packet.read();
    let p_fences: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkResetFences({device:?}, {fence_count:?}, {p_fences:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_fences)(
            device,
            fence_count,
            p_fences,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetFenceStatus.html>"]
fn vk_get_fence_status(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let fence: NonDisposableHandle = packet.read();
    trace!("called vkGetFenceStatus({device:?}, {fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_fence_status)(
            device,
            fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForFences.html>"]
fn vk_wait_for_fences(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let fence_count: u32 = packet.read();
    let p_fences: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let wait_all: NonDisposableHandle = packet.read();
    let timeout: u64 = packet.read();
    trace!("called vkWaitForFences({device:?}, {fence_count:?}, {p_fences:?}, {wait_all:?}, {timeout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_wait_for_fences)(
            device,
            fence_count,
            p_fences,
            wait_all,
            timeout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSemaphore.html>"]
fn vk_create_semaphore(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkSemaphoreCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_semaphore: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateSemaphore({device:?}, {p_create_info:?}, {p_allocator:?}, {p_semaphore:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_semaphore)(
            device,
            p_create_info,
            p_allocator,
            p_semaphore,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_semaphore);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroySemaphore.html>"]
fn vk_destroy_semaphore(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let semaphore: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroySemaphore({device:?}, {semaphore:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_semaphore)(
            device,
            semaphore,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateEvent.html>"]
fn vk_create_event(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkEventCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_event: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateEvent({device:?}, {p_create_info:?}, {p_allocator:?}, {p_event:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_event)(
            device,
            p_create_info,
            p_allocator,
            p_event,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_event);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyEvent.html>"]
fn vk_destroy_event(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyEvent({device:?}, {event:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_event)(
            device,
            event,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetEventStatus.html>"]
fn vk_get_event_status(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    trace!("called vkGetEventStatus({device:?}, {event:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_event_status)(
            device,
            event,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetEvent.html>"]
fn vk_set_event(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    trace!("called vkSetEvent({device:?}, {event:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_event)(
            device,
            event,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetEvent.html>"]
fn vk_reset_event(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    trace!("called vkResetEvent({device:?}, {event:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_event)(
            device,
            event,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateQueryPool.html>"]
fn vk_create_query_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkQueryPoolCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_query_pool: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateQueryPool({device:?}, {p_create_info:?}, {p_allocator:?}, {p_query_pool:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_query_pool)(
            device,
            p_create_info,
            p_allocator,
            p_query_pool,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_query_pool);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyQueryPool.html>"]
fn vk_destroy_query_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyQueryPool({device:?}, {query_pool:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_query_pool)(
            device,
            query_pool,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetQueryPoolResults.html>"]
fn vk_get_query_pool_results(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    let query_count: u32 = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    let stride: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkGetQueryPoolResults({device:?}, {query_pool:?}, {first_query:?}, {query_count:?}, {data_size:?}, {p_data:?}, {stride:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_query_pool_results)(
            device,
            query_pool,
            first_query,
            query_count,
            data_size,
            p_data,
            stride,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetQueryPool.html>"]
fn vk_reset_query_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    let query_count: u32 = packet.read();
    trace!("called vkResetQueryPool({device:?}, {query_pool:?}, {first_query:?}, {query_count:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_query_pool)(
            device,
            query_pool,
            first_query,
            query_count,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateBuffer.html>"]
fn vk_create_buffer(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkBufferCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_buffer: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateBuffer({device:?}, {p_create_info:?}, {p_allocator:?}, {p_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_buffer)(
            device,
            p_create_info,
            p_allocator,
            p_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_buffer);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyBuffer.html>"]
fn vk_destroy_buffer(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyBuffer({device:?}, {buffer:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_buffer)(
            device,
            buffer,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateBufferView.html>"]
fn vk_create_buffer_view(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkBufferViewCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_view: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateBufferView({device:?}, {p_create_info:?}, {p_allocator:?}, {p_view:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_buffer_view)(
            device,
            p_create_info,
            p_allocator,
            p_view,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_view);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferView.html>"]
fn vk_destroy_buffer_view(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer_view: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyBufferView({device:?}, {buffer_view:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_buffer_view)(
            device,
            buffer_view,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateImage.html>"]
fn vk_create_image(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkImageCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_image: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateImage({device:?}, {p_create_info:?}, {p_allocator:?}, {p_image:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_image)(
            device,
            p_create_info,
            p_allocator,
            p_image,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_image);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyImage.html>"]
fn vk_destroy_image(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyImage({device:?}, {image:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_image)(
            device,
            image,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout.html>"]
fn vk_get_image_subresource_layout(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let p_subresource: *const VkImageSubresource = packet.read_nullable_raw_ptr();
    let p_layout: *mut VkSubresourceLayout = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageSubresourceLayout({device:?}, {image:?}, {p_subresource:?}, {p_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_subresource_layout)(
            device,
            image,
            p_subresource,
            p_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateImageView.html>"]
fn vk_create_image_view(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkImageViewCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_view: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateImageView({device:?}, {p_create_info:?}, {p_allocator:?}, {p_view:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_image_view)(
            device,
            p_create_info,
            p_allocator,
            p_view,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_view);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyImageView.html>"]
fn vk_destroy_image_view(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image_view: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyImageView({device:?}, {image_view:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_image_view)(
            device,
            image_view,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateShaderModule.html>"]
fn vk_create_shader_module(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkShaderModuleCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_shader_module: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateShaderModule({device:?}, {p_create_info:?}, {p_allocator:?}, {p_shader_module:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_shader_module)(
            device,
            p_create_info,
            p_allocator,
            p_shader_module,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_shader_module);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderModule.html>"]
fn vk_destroy_shader_module(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let shader_module: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyShaderModule({device:?}, {shader_module:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_shader_module)(
            device,
            shader_module,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineCache.html>"]
fn vk_create_pipeline_cache(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkPipelineCacheCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipeline_cache: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreatePipelineCache({device:?}, {p_create_info:?}, {p_allocator:?}, {p_pipeline_cache:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_pipeline_cache)(
            device,
            p_create_info,
            p_allocator,
            p_pipeline_cache,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipeline_cache);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineCache.html>"]
fn vk_destroy_pipeline_cache(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyPipelineCache({device:?}, {pipeline_cache:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_pipeline_cache)(
            device,
            pipeline_cache,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineCacheData.html>"]
fn vk_get_pipeline_cache_data(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let p_data_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPipelineCacheData({device:?}, {pipeline_cache:?}, {p_data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_cache_data)(
            device,
            pipeline_cache,
            p_data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data_size);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMergePipelineCaches.html>"]
fn vk_merge_pipeline_caches(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let dst_cache: NonDisposableHandle = packet.read();
    let src_cache_count: u32 = packet.read();
    let p_src_caches: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkMergePipelineCaches({device:?}, {dst_cache:?}, {src_cache_count:?}, {p_src_caches:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_merge_pipeline_caches)(
            device,
            dst_cache,
            src_cache_count,
            p_src_caches,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateGraphicsPipelines.html>"]
fn vk_create_graphics_pipelines(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkGraphicsPipelineCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipelines: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateGraphicsPipelines({device:?}, {pipeline_cache:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_pipelines:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_graphics_pipelines)(
            device,
            pipeline_cache,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_pipelines,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipelines);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateComputePipelines.html>"]
fn vk_create_compute_pipelines(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkComputePipelineCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipelines: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateComputePipelines({device:?}, {pipeline_cache:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_pipelines:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_compute_pipelines)(
            device,
            pipeline_cache,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_pipelines,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipelines);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI.html>"]
fn vk_get_device_subpass_shading_max_workgroup_size_huawei(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let renderpass: NonDisposableHandle = packet.read();
    let p_max_workgroup_size: *mut VkExtent2D = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI({device:?}, {renderpass:?}, {p_max_workgroup_size:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_subpass_shading_max_workgroup_size_huawei)(
            device,
            renderpass,
            p_max_workgroup_size,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_max_workgroup_size);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyPipeline.html>"]
fn vk_destroy_pipeline(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyPipeline({device:?}, {pipeline:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_pipeline)(
            device,
            pipeline,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreatePipelineLayout.html>"]
fn vk_create_pipeline_layout(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkPipelineLayoutCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipeline_layout: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreatePipelineLayout({device:?}, {p_create_info:?}, {p_allocator:?}, {p_pipeline_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_pipeline_layout)(
            device,
            p_create_info,
            p_allocator,
            p_pipeline_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipeline_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyPipelineLayout.html>"]
fn vk_destroy_pipeline_layout(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_layout: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyPipelineLayout({device:?}, {pipeline_layout:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_pipeline_layout)(
            device,
            pipeline_layout,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSampler.html>"]
fn vk_create_sampler(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkSamplerCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_sampler: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateSampler({device:?}, {p_create_info:?}, {p_allocator:?}, {p_sampler:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_sampler)(
            device,
            p_create_info,
            p_allocator,
            p_sampler,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_sampler);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroySampler.html>"]
fn vk_destroy_sampler(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let sampler: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroySampler({device:?}, {sampler:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_sampler)(
            device,
            sampler,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorSetLayout.html>"]
fn vk_create_descriptor_set_layout(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDescriptorSetLayoutCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_set_layout: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDescriptorSetLayout({device:?}, {p_create_info:?}, {p_allocator:?}, {p_set_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_descriptor_set_layout)(
            device,
            p_create_info,
            p_allocator,
            p_set_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_set_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorSetLayout.html>"]
fn vk_destroy_descriptor_set_layout(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_set_layout: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDescriptorSetLayout({device:?}, {descriptor_set_layout:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_descriptor_set_layout)(
            device,
            descriptor_set_layout,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorPool.html>"]
fn vk_create_descriptor_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDescriptorPoolCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_descriptor_pool: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDescriptorPool({device:?}, {p_create_info:?}, {p_allocator:?}, {p_descriptor_pool:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_descriptor_pool)(
            device,
            p_create_info,
            p_allocator,
            p_descriptor_pool,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_descriptor_pool);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorPool.html>"]
fn vk_destroy_descriptor_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_pool: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDescriptorPool({device:?}, {descriptor_pool:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_descriptor_pool)(
            device,
            descriptor_pool,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetDescriptorPool.html>"]
fn vk_reset_descriptor_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_pool: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkResetDescriptorPool({device:?}, {descriptor_pool:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_descriptor_pool)(
            device,
            descriptor_pool,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateDescriptorSets.html>"]
fn vk_allocate_descriptor_sets(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_allocate_info: *const VkDescriptorSetAllocateInfo = packet.read_nullable_raw_ptr();
    let p_descriptor_sets: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAllocateDescriptorSets({device:?}, {p_allocate_info:?}, {p_descriptor_sets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_allocate_descriptor_sets)(
            device,
            p_allocate_info,
            p_descriptor_sets,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_descriptor_sets);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkFreeDescriptorSets.html>"]
fn vk_free_descriptor_sets(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_pool: NonDisposableHandle = packet.read();
    let descriptor_set_count: u32 = packet.read();
    let p_descriptor_sets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkFreeDescriptorSets({device:?}, {descriptor_pool:?}, {descriptor_set_count:?}, {p_descriptor_sets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_free_descriptor_sets)(
            device,
            descriptor_pool,
            descriptor_set_count,
            p_descriptor_sets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSets.html>"]
fn vk_update_descriptor_sets(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_write_count: u32 = packet.read();
    let p_descriptor_writes: *const VkWriteDescriptorSet = packet.read_nullable_raw_ptr();
    let descriptor_copy_count: u32 = packet.read();
    let p_descriptor_copies: *const VkCopyDescriptorSet = packet.read_nullable_raw_ptr();
    trace!("called vkUpdateDescriptorSets({device:?}, {descriptor_write_count:?}, {p_descriptor_writes:?}, {descriptor_copy_count:?}, {p_descriptor_copies:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_update_descriptor_sets)(
            device,
            descriptor_write_count,
            p_descriptor_writes,
            descriptor_copy_count,
            p_descriptor_copies,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateFramebuffer.html>"]
fn vk_create_framebuffer(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkFramebufferCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_framebuffer: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateFramebuffer({device:?}, {p_create_info:?}, {p_allocator:?}, {p_framebuffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_framebuffer)(
            device,
            p_create_info,
            p_allocator,
            p_framebuffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_framebuffer);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyFramebuffer.html>"]
fn vk_destroy_framebuffer(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let framebuffer: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyFramebuffer({device:?}, {framebuffer:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_framebuffer)(
            device,
            framebuffer,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass.html>"]
fn vk_create_render_pass(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkRenderPassCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_render_pass: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateRenderPass({device:?}, {p_create_info:?}, {p_allocator:?}, {p_render_pass:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_render_pass)(
            device,
            p_create_info,
            p_allocator,
            p_render_pass,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_render_pass);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyRenderPass.html>"]
fn vk_destroy_render_pass(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let render_pass: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyRenderPass({device:?}, {render_pass:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_render_pass)(
            device,
            render_pass,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRenderAreaGranularity.html>"]
fn vk_get_render_area_granularity(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let render_pass: NonDisposableHandle = packet.read();
    let p_granularity: *mut VkExtent2D = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRenderAreaGranularity({device:?}, {render_pass:?}, {p_granularity:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_render_area_granularity)(
            device,
            render_pass,
            p_granularity,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_granularity);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRenderingAreaGranularityKHR.html>"]
fn vk_get_rendering_area_granularity_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_rendering_area_info: *const VkRenderingAreaInfoKHR = packet.read_nullable_raw_ptr();
    let p_granularity: *mut VkExtent2D = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRenderingAreaGranularityKHR({device:?}, {p_rendering_area_info:?}, {p_granularity:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_rendering_area_granularity_khr)(
            device,
            p_rendering_area_info,
            p_granularity,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_granularity);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateCommandPool.html>"]
fn vk_create_command_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkCommandPoolCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_command_pool: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateCommandPool({device:?}, {p_create_info:?}, {p_allocator:?}, {p_command_pool:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_command_pool)(
            device,
            p_create_info,
            p_allocator,
            p_command_pool,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_command_pool);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyCommandPool.html>"]
fn vk_destroy_command_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let command_pool: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyCommandPool({device:?}, {command_pool:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_command_pool)(
            device,
            command_pool,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandPool.html>"]
fn vk_reset_command_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let command_pool: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkResetCommandPool({device:?}, {command_pool:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_command_pool)(
            device,
            command_pool,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAllocateCommandBuffers.html>"]
fn vk_allocate_command_buffers(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_allocate_info: *const VkCommandBufferAllocateInfo = packet.read_nullable_raw_ptr();
    let p_command_buffers: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAllocateCommandBuffers({device:?}, {p_allocate_info:?}, {p_command_buffers:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_allocate_command_buffers)(
            device,
            p_allocate_info,
            p_command_buffers,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_command_buffers);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkFreeCommandBuffers.html>"]
fn vk_free_command_buffers(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let command_pool: NonDisposableHandle = packet.read();
    let command_buffer_count: u32 = packet.read();
    let p_command_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkFreeCommandBuffers({device:?}, {command_pool:?}, {command_buffer_count:?}, {p_command_buffers:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_free_command_buffers)(
            device,
            command_pool,
            command_buffer_count,
            p_command_buffers,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBeginCommandBuffer.html>"]
fn vk_begin_command_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_begin_info: *const VkCommandBufferBeginInfo = packet.read_nullable_raw_ptr();
    trace!("called vkBeginCommandBuffer({command_buffer:?}, {p_begin_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_begin_command_buffer)(
            command_buffer,
            p_begin_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEndCommandBuffer.html>"]
fn vk_end_command_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkEndCommandBuffer({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_end_command_buffer)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkResetCommandBuffer.html>"]
fn vk_reset_command_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkResetCommandBuffer({command_buffer:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_reset_command_buffer)(
            command_buffer,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipeline.html>"]
fn vk_cmd_bind_pipeline(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    trace!("called vkCmdBindPipeline({command_buffer:?}, {pipeline_bind_point:?}, {pipeline:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_pipeline)(
            command_buffer,
            pipeline_bind_point,
            pipeline,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetAttachmentFeedbackLoopEnableEXT.html>"]
fn vk_cmd_set_attachment_feedback_loop_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let aspect_mask: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetAttachmentFeedbackLoopEnableEXT({command_buffer:?}, {aspect_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_attachment_feedback_loop_enable_ext)(
            command_buffer,
            aspect_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewport.html>"]
fn vk_cmd_set_viewport(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_viewport: u32 = packet.read();
    let viewport_count: u32 = packet.read();
    let p_viewports: *const VkViewport = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetViewport({command_buffer:?}, {first_viewport:?}, {viewport_count:?}, {p_viewports:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport)(
            command_buffer,
            first_viewport,
            viewport_count,
            p_viewports,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissor.html>"]
fn vk_cmd_set_scissor(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_scissor: u32 = packet.read();
    let scissor_count: u32 = packet.read();
    let p_scissors: *const VkRect2D = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetScissor({command_buffer:?}, {first_scissor:?}, {scissor_count:?}, {p_scissors:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_scissor)(
            command_buffer,
            first_scissor,
            scissor_count,
            p_scissors,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineWidth.html>"]
fn vk_cmd_set_line_width(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let line_width: f32 = packet.read();
    trace!("called vkCmdSetLineWidth({command_buffer:?}, {line_width:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_line_width)(
            command_buffer,
            line_width,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias.html>"]
fn vk_cmd_set_depth_bias(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_bias_constant_factor: f32 = packet.read();
    let depth_bias_clamp: f32 = packet.read();
    let depth_bias_slope_factor: f32 = packet.read();
    trace!("called vkCmdSetDepthBias({command_buffer:?}, {depth_bias_constant_factor:?}, {depth_bias_clamp:?}, {depth_bias_slope_factor:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_bias)(
            command_buffer,
            depth_bias_constant_factor,
            depth_bias_clamp,
            depth_bias_slope_factor,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetBlendConstants.html>"]
fn vk_cmd_set_blend_constants(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let blend_constants: [f32; 4] = packet.read();
    trace!("called vkCmdSetBlendConstants({command_buffer:?}, {blend_constants:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_blend_constants)(
            command_buffer,
            blend_constants,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBounds.html>"]
fn vk_cmd_set_depth_bounds(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let min_depth_bounds: f32 = packet.read();
    let max_depth_bounds: f32 = packet.read();
    trace!("called vkCmdSetDepthBounds({command_buffer:?}, {min_depth_bounds:?}, {max_depth_bounds:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_bounds)(
            command_buffer,
            min_depth_bounds,
            max_depth_bounds,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilCompareMask.html>"]
fn vk_cmd_set_stencil_compare_mask(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let face_mask: NonDisposableHandle = packet.read();
    let compare_mask: u32 = packet.read();
    trace!("called vkCmdSetStencilCompareMask({command_buffer:?}, {face_mask:?}, {compare_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_stencil_compare_mask)(
            command_buffer,
            face_mask,
            compare_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilWriteMask.html>"]
fn vk_cmd_set_stencil_write_mask(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let face_mask: NonDisposableHandle = packet.read();
    let write_mask: u32 = packet.read();
    trace!("called vkCmdSetStencilWriteMask({command_buffer:?}, {face_mask:?}, {write_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_stencil_write_mask)(
            command_buffer,
            face_mask,
            write_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilReference.html>"]
fn vk_cmd_set_stencil_reference(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let face_mask: NonDisposableHandle = packet.read();
    let reference: u32 = packet.read();
    trace!("called vkCmdSetStencilReference({command_buffer:?}, {face_mask:?}, {reference:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_stencil_reference)(
            command_buffer,
            face_mask,
            reference,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets.html>"]
fn vk_cmd_bind_descriptor_sets(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let first_set: u32 = packet.read();
    let descriptor_set_count: u32 = packet.read();
    let p_descriptor_sets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let dynamic_offset_count: u32 = packet.read();
    let p_dynamic_offsets: *const u32 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindDescriptorSets({command_buffer:?}, {pipeline_bind_point:?}, {layout:?}, {first_set:?}, {descriptor_set_count:?}, {p_descriptor_sets:?}, {dynamic_offset_count:?}, {p_dynamic_offsets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_descriptor_sets)(
            command_buffer,
            pipeline_bind_point,
            layout,
            first_set,
            descriptor_set_count,
            p_descriptor_sets,
            dynamic_offset_count,
            p_dynamic_offsets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer.html>"]
fn vk_cmd_bind_index_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let index_type: NonDisposableHandle = packet.read();
    trace!("called vkCmdBindIndexBuffer({command_buffer:?}, {buffer:?}, {offset:?}, {index_type:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_index_buffer)(
            command_buffer,
            buffer,
            offset,
            index_type,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers.html>"]
fn vk_cmd_bind_vertex_buffers(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_binding: u32 = packet.read();
    let binding_count: u32 = packet.read();
    let p_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindVertexBuffers({command_buffer:?}, {first_binding:?}, {binding_count:?}, {p_buffers:?}, {p_offsets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_vertex_buffers)(
            command_buffer,
            first_binding,
            binding_count,
            p_buffers,
            p_offsets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDraw.html>"]
fn vk_cmd_draw(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let vertex_count: u32 = packet.read();
    let instance_count: u32 = packet.read();
    let first_vertex: u32 = packet.read();
    let first_instance: u32 = packet.read();
    trace!("called vkCmdDraw({command_buffer:?}, {vertex_count:?}, {instance_count:?}, {first_vertex:?}, {first_instance:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw)(
            command_buffer,
            vertex_count,
            instance_count,
            first_vertex,
            first_instance,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexed.html>"]
fn vk_cmd_draw_indexed(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let index_count: u32 = packet.read();
    let instance_count: u32 = packet.read();
    let first_index: u32 = packet.read();
    let vertex_offset: i32 = packet.read();
    let first_instance: u32 = packet.read();
    trace!("called vkCmdDrawIndexed({command_buffer:?}, {index_count:?}, {instance_count:?}, {first_index:?}, {vertex_offset:?}, {first_instance:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indexed)(
            command_buffer,
            index_count,
            instance_count,
            first_index,
            vertex_offset,
            first_instance,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiEXT.html>"]
fn vk_cmd_draw_multi_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let p_vertex_info: *const VkMultiDrawInfoEXT = packet.read_nullable_raw_ptr();
    let instance_count: u32 = packet.read();
    let first_instance: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawMultiEXT({command_buffer:?}, {draw_count:?}, {p_vertex_info:?}, {instance_count:?}, {first_instance:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_multi_ext)(
            command_buffer,
            draw_count,
            p_vertex_info,
            instance_count,
            first_instance,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMultiIndexedEXT.html>"]
fn vk_cmd_draw_multi_indexed_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let p_index_info: *const VkMultiDrawIndexedInfoEXT = packet.read_nullable_raw_ptr();
    let instance_count: u32 = packet.read();
    let first_instance: u32 = packet.read();
    let stride: u32 = packet.read();
    let p_vertex_offset: *const i32 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDrawMultiIndexedEXT({command_buffer:?}, {draw_count:?}, {p_index_info:?}, {instance_count:?}, {first_instance:?}, {stride:?}, {p_vertex_offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_multi_indexed_ext)(
            command_buffer,
            draw_count,
            p_index_info,
            instance_count,
            first_instance,
            stride,
            p_vertex_offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirect.html>"]
fn vk_cmd_draw_indirect(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawIndirect({command_buffer:?}, {buffer:?}, {offset:?}, {draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indirect)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirect.html>"]
fn vk_cmd_draw_indexed_indirect(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawIndexedIndirect({command_buffer:?}, {buffer:?}, {offset:?}, {draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indexed_indirect)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatch.html>"]
fn vk_cmd_dispatch(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let group_count_x: u32 = packet.read();
    let group_count_y: u32 = packet.read();
    let group_count_z: u32 = packet.read();
    trace!("called vkCmdDispatch({command_buffer:?}, {group_count_x:?}, {group_count_y:?}, {group_count_z:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch)(
            command_buffer,
            group_count_x,
            group_count_y,
            group_count_z,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchIndirect.html>"]
fn vk_cmd_dispatch_indirect(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    trace!("called vkCmdDispatchIndirect({command_buffer:?}, {buffer:?}, {offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch_indirect)(
            command_buffer,
            buffer,
            offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSubpassShadingHUAWEI.html>"]
fn vk_cmd_subpass_shading_huawei(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdSubpassShadingHUAWEI({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_subpass_shading_huawei)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterHUAWEI.html>"]
fn vk_cmd_draw_cluster_huawei(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let group_count_x: u32 = packet.read();
    let group_count_y: u32 = packet.read();
    let group_count_z: u32 = packet.read();
    trace!("called vkCmdDrawClusterHUAWEI({command_buffer:?}, {group_count_x:?}, {group_count_y:?}, {group_count_z:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_cluster_huawei)(
            command_buffer,
            group_count_x,
            group_count_y,
            group_count_z,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawClusterIndirectHUAWEI.html>"]
fn vk_cmd_draw_cluster_indirect_huawei(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    trace!("called vkCmdDrawClusterIndirectHUAWEI({command_buffer:?}, {buffer:?}, {offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_cluster_indirect_huawei)(
            command_buffer,
            buffer,
            offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdUpdatePipelineIndirectBufferNV.html>"]
fn vk_cmd_update_pipeline_indirect_buffer_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    trace!("called vkCmdUpdatePipelineIndirectBufferNV({command_buffer:?}, {pipeline_bind_point:?}, {pipeline:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_update_pipeline_indirect_buffer_nv)(
            command_buffer,
            pipeline_bind_point,
            pipeline,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer.html>"]
fn vk_cmd_copy_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_buffer: NonDisposableHandle = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkBufferCopy = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyBuffer({command_buffer:?}, {src_buffer:?}, {dst_buffer:?}, {region_count:?}, {p_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_buffer)(
            command_buffer,
            src_buffer,
            dst_buffer,
            region_count,
            p_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage.html>"]
fn vk_cmd_copy_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_image: NonDisposableHandle = packet.read();
    let src_image_layout: NonDisposableHandle = packet.read();
    let dst_image: NonDisposableHandle = packet.read();
    let dst_image_layout: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkImageCopy = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyImage({command_buffer:?}, {src_image:?}, {src_image_layout:?}, {dst_image:?}, {dst_image_layout:?}, {region_count:?}, {p_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_image)(
            command_buffer,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            region_count,
            p_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html>"]
fn vk_cmd_blit_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_image: NonDisposableHandle = packet.read();
    let src_image_layout: NonDisposableHandle = packet.read();
    let dst_image: NonDisposableHandle = packet.read();
    let dst_image_layout: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkImageBlit = packet.read_nullable_raw_ptr();
    let filter: NonDisposableHandle = packet.read();
    trace!("called vkCmdBlitImage({command_buffer:?}, {src_image:?}, {src_image_layout:?}, {dst_image:?}, {dst_image_layout:?}, {region_count:?}, {p_regions:?}, {filter:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_blit_image)(
            command_buffer,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            region_count,
            p_regions,
            filter,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html>"]
fn vk_cmd_copy_buffer_to_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_buffer: NonDisposableHandle = packet.read();
    let dst_image: NonDisposableHandle = packet.read();
    let dst_image_layout: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkBufferImageCopy = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyBufferToImage({command_buffer:?}, {src_buffer:?}, {dst_image:?}, {dst_image_layout:?}, {region_count:?}, {p_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_buffer_to_image)(
            command_buffer,
            src_buffer,
            dst_image,
            dst_image_layout,
            region_count,
            p_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer.html>"]
fn vk_cmd_copy_image_to_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_image: NonDisposableHandle = packet.read();
    let src_image_layout: NonDisposableHandle = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkBufferImageCopy = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyImageToBuffer({command_buffer:?}, {src_image:?}, {src_image_layout:?}, {dst_buffer:?}, {region_count:?}, {p_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_image_to_buffer)(
            command_buffer,
            src_image,
            src_image_layout,
            dst_buffer,
            region_count,
            p_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryIndirectNV.html>"]
fn vk_cmd_copy_memory_indirect_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let copy_buffer_address: NonDisposableHandle = packet.read();
    let copy_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdCopyMemoryIndirectNV({command_buffer:?}, {copy_buffer_address:?}, {copy_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_memory_indirect_nv)(
            command_buffer,
            copy_buffer_address,
            copy_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToImageIndirectNV.html>"]
fn vk_cmd_copy_memory_to_image_indirect_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let copy_buffer_address: NonDisposableHandle = packet.read();
    let copy_count: u32 = packet.read();
    let stride: u32 = packet.read();
    let dst_image: NonDisposableHandle = packet.read();
    let dst_image_layout: NonDisposableHandle = packet.read();
    let p_image_subresources: *const VkImageSubresourceLayers = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyMemoryToImageIndirectNV({command_buffer:?}, {copy_buffer_address:?}, {copy_count:?}, {stride:?}, {dst_image:?}, {dst_image_layout:?}, {p_image_subresources:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_memory_to_image_indirect_nv)(
            command_buffer,
            copy_buffer_address,
            copy_count,
            stride,
            dst_image,
            dst_image_layout,
            p_image_subresources,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdUpdateBuffer.html>"]
fn vk_cmd_update_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let dst_offset: NonDisposableHandle = packet.read();
    let data_size: NonDisposableHandle = packet.read();
    let p_data: *const c_void = packet.read_nullable_raw_ptr();
    trace!("called vkCmdUpdateBuffer({command_buffer:?}, {dst_buffer:?}, {dst_offset:?}, {data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_update_buffer)(
            command_buffer,
            dst_buffer,
            dst_offset,
            data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdFillBuffer.html>"]
fn vk_cmd_fill_buffer(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let dst_offset: NonDisposableHandle = packet.read();
    let size: NonDisposableHandle = packet.read();
    let data: u32 = packet.read();
    trace!("called vkCmdFillBuffer({command_buffer:?}, {dst_buffer:?}, {dst_offset:?}, {size:?}, {data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_fill_buffer)(
            command_buffer,
            dst_buffer,
            dst_offset,
            size,
            data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdClearColorImage.html>"]
fn vk_cmd_clear_color_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let image_layout: NonDisposableHandle = packet.read();
    let p_color: *const VkClearColorValue = packet.read_nullable_raw_ptr();
    let range_count: u32 = packet.read();
    let p_ranges: *const VkImageSubresourceRange = packet.read_nullable_raw_ptr();
    trace!("called vkCmdClearColorImage({command_buffer:?}, {image:?}, {image_layout:?}, {p_color:?}, {range_count:?}, {p_ranges:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_clear_color_image)(
            command_buffer,
            image,
            image_layout,
            p_color,
            range_count,
            p_ranges,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdClearDepthStencilImage.html>"]
fn vk_cmd_clear_depth_stencil_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let image_layout: NonDisposableHandle = packet.read();
    let p_depth_stencil: *const VkClearDepthStencilValue = packet.read_nullable_raw_ptr();
    let range_count: u32 = packet.read();
    let p_ranges: *const VkImageSubresourceRange = packet.read_nullable_raw_ptr();
    trace!("called vkCmdClearDepthStencilImage({command_buffer:?}, {image:?}, {image_layout:?}, {p_depth_stencil:?}, {range_count:?}, {p_ranges:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_clear_depth_stencil_image)(
            command_buffer,
            image,
            image_layout,
            p_depth_stencil,
            range_count,
            p_ranges,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdClearAttachments.html>"]
fn vk_cmd_clear_attachments(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let attachment_count: u32 = packet.read();
    let p_attachments: *const VkClearAttachment = packet.read_nullable_raw_ptr();
    let rect_count: u32 = packet.read();
    let p_rects: *const VkClearRect = packet.read_nullable_raw_ptr();
    trace!("called vkCmdClearAttachments({command_buffer:?}, {attachment_count:?}, {p_attachments:?}, {rect_count:?}, {p_rects:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_clear_attachments)(
            command_buffer,
            attachment_count,
            p_attachments,
            rect_count,
            p_rects,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage.html>"]
fn vk_cmd_resolve_image(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_image: NonDisposableHandle = packet.read();
    let src_image_layout: NonDisposableHandle = packet.read();
    let dst_image: NonDisposableHandle = packet.read();
    let dst_image_layout: NonDisposableHandle = packet.read();
    let region_count: u32 = packet.read();
    let p_regions: *const VkImageResolve = packet.read_nullable_raw_ptr();
    trace!("called vkCmdResolveImage({command_buffer:?}, {src_image:?}, {src_image_layout:?}, {dst_image:?}, {dst_image_layout:?}, {region_count:?}, {p_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_resolve_image)(
            command_buffer,
            src_image,
            src_image_layout,
            dst_image,
            dst_image_layout,
            region_count,
            p_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent.html>"]
fn vk_cmd_set_event(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    let stage_mask: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetEvent({command_buffer:?}, {event:?}, {stage_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_event)(
            command_buffer,
            event,
            stage_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent.html>"]
fn vk_cmd_reset_event(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    let stage_mask: NonDisposableHandle = packet.read();
    trace!("called vkCmdResetEvent({command_buffer:?}, {event:?}, {stage_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_reset_event)(
            command_buffer,
            event,
            stage_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents.html>"]
fn vk_cmd_wait_events(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event_count: u32 = packet.read();
    let p_events: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let src_stage_mask: NonDisposableHandle = packet.read();
    let dst_stage_mask: NonDisposableHandle = packet.read();
    let memory_barrier_count: u32 = packet.read();
    let p_memory_barriers: *const VkMemoryBarrier = packet.read_nullable_raw_ptr();
    let buffer_memory_barrier_count: u32 = packet.read();
    let p_buffer_memory_barriers: *const VkBufferMemoryBarrier = packet.read_nullable_raw_ptr();
    let image_memory_barrier_count: u32 = packet.read();
    let p_image_memory_barriers: *const VkImageMemoryBarrier = packet.read_nullable_raw_ptr();
    trace!("called vkCmdWaitEvents({command_buffer:?}, {event_count:?}, {p_events:?}, {src_stage_mask:?}, {dst_stage_mask:?}, {memory_barrier_count:?}, {p_memory_barriers:?}, {buffer_memory_barrier_count:?}, {p_buffer_memory_barriers:?}, {image_memory_barrier_count:?}, {p_image_memory_barriers:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_wait_events)(
            command_buffer,
            event_count,
            p_events,
            src_stage_mask,
            dst_stage_mask,
            memory_barrier_count,
            p_memory_barriers,
            buffer_memory_barrier_count,
            p_buffer_memory_barriers,
            image_memory_barrier_count,
            p_image_memory_barriers,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier.html>"]
fn vk_cmd_pipeline_barrier(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let src_stage_mask: NonDisposableHandle = packet.read();
    let dst_stage_mask: NonDisposableHandle = packet.read();
    let dependency_flags: NonDisposableHandle = packet.read();
    let memory_barrier_count: u32 = packet.read();
    let p_memory_barriers: *const VkMemoryBarrier = packet.read_nullable_raw_ptr();
    let buffer_memory_barrier_count: u32 = packet.read();
    let p_buffer_memory_barriers: *const VkBufferMemoryBarrier = packet.read_nullable_raw_ptr();
    let image_memory_barrier_count: u32 = packet.read();
    let p_image_memory_barriers: *const VkImageMemoryBarrier = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPipelineBarrier({command_buffer:?}, {src_stage_mask:?}, {dst_stage_mask:?}, {dependency_flags:?}, {memory_barrier_count:?}, {p_memory_barriers:?}, {buffer_memory_barrier_count:?}, {p_buffer_memory_barriers:?}, {image_memory_barrier_count:?}, {p_image_memory_barriers:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_pipeline_barrier)(
            command_buffer,
            src_stage_mask,
            dst_stage_mask,
            dependency_flags,
            memory_barrier_count,
            p_memory_barriers,
            buffer_memory_barrier_count,
            p_buffer_memory_barriers,
            image_memory_barrier_count,
            p_image_memory_barriers,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQuery.html>"]
fn vk_cmd_begin_query(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkCmdBeginQuery({command_buffer:?}, {query_pool:?}, {query:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_query)(
            command_buffer,
            query_pool,
            query,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndQuery.html>"]
fn vk_cmd_end_query(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    trace!("called vkCmdEndQuery({command_buffer:?}, {query_pool:?}, {query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_query)(
            command_buffer,
            query_pool,
            query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginConditionalRenderingEXT.html>"]
fn vk_cmd_begin_conditional_rendering_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_conditional_rendering_begin: *const VkConditionalRenderingBeginInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginConditionalRenderingEXT({command_buffer:?}, {p_conditional_rendering_begin:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_conditional_rendering_ext)(
            command_buffer,
            p_conditional_rendering_begin,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndConditionalRenderingEXT.html>"]
fn vk_cmd_end_conditional_rendering_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdEndConditionalRenderingEXT({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_conditional_rendering_ext)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdResetQueryPool.html>"]
fn vk_cmd_reset_query_pool(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    let query_count: u32 = packet.read();
    trace!("called vkCmdResetQueryPool({command_buffer:?}, {query_pool:?}, {first_query:?}, {query_count:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_reset_query_pool)(
            command_buffer,
            query_pool,
            first_query,
            query_count,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp.html>"]
fn vk_cmd_write_timestamp(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_stage: vk::PipelineStageFlags = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    trace!("called vkCmdWriteTimestamp({command_buffer:?}, {pipeline_stage:?}, {query_pool:?}, {query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_timestamp)(
            command_buffer,
            pipeline_stage,
            query_pool,
            query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyQueryPoolResults.html>"]
fn vk_cmd_copy_query_pool_results(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    let query_count: u32 = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let dst_offset: NonDisposableHandle = packet.read();
    let stride: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkCmdCopyQueryPoolResults({command_buffer:?}, {query_pool:?}, {first_query:?}, {query_count:?}, {dst_buffer:?}, {dst_offset:?}, {stride:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_query_pool_results)(
            command_buffer,
            query_pool,
            first_query,
            query_count,
            dst_buffer,
            dst_offset,
            stride,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants.html>"]
fn vk_cmd_push_constants(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let stage_flags: NonDisposableHandle = packet.read();
    let offset: u32 = packet.read();
    let size: u32 = packet.read();
    let p_values: *const c_void = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushConstants({command_buffer:?}, {layout:?}, {stage_flags:?}, {offset:?}, {size:?}, {p_values:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_constants)(
            command_buffer,
            layout,
            stage_flags,
            offset,
            size,
            p_values,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass.html>"]
fn vk_cmd_begin_render_pass(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_render_pass_begin: *const VkRenderPassBeginInfo = packet.read_nullable_raw_ptr();
    let contents: NonDisposableHandle = packet.read();
    trace!("called vkCmdBeginRenderPass({command_buffer:?}, {p_render_pass_begin:?}, {contents:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_render_pass)(
            command_buffer,
            p_render_pass_begin,
            contents,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass.html>"]
fn vk_cmd_next_subpass(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let contents: NonDisposableHandle = packet.read();
    trace!("called vkCmdNextSubpass({command_buffer:?}, {contents:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_next_subpass)(
            command_buffer,
            contents,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass.html>"]
fn vk_cmd_end_render_pass(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdEndRenderPass({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_render_pass)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteCommands.html>"]
fn vk_cmd_execute_commands(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let command_buffer_count: u32 = packet.read();
    let p_command_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdExecuteCommands({command_buffer:?}, {command_buffer_count:?}, {p_command_buffers:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_execute_commands)(
            command_buffer,
            command_buffer_count,
            p_command_buffers,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateAndroidSurfaceKHR.html>"]
fn vk_create_android_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkAndroidSurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateAndroidSurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_android_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html>"]
fn vk_get_physical_device_display_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayPropertiesKHR>();
    trace!("called vkGetPhysicalDeviceDisplayPropertiesKHR({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_display_properties_khr)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html>"]
fn vk_get_physical_device_display_plane_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayPlanePropertiesKHR>();
    trace!("called vkGetPhysicalDeviceDisplayPlanePropertiesKHR({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_display_plane_properties_khr)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html>"]
fn vk_get_display_plane_supported_displays_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let plane_index: u32 = packet.read();
    let (mut p_display_count, p_displays) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkGetDisplayPlaneSupportedDisplaysKHR({physical_device:?}, {plane_index:?}, {p_display_count:?}, {p_displays:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_display_plane_supported_displays_khr)(
            physical_device,
            plane_index,
            &mut p_display_count,
            p_displays,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_display_count, p_displays);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModePropertiesKHR.html>"]
fn vk_get_display_mode_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayModePropertiesKHR>();
    trace!("called vkGetDisplayModePropertiesKHR({physical_device:?}, {display:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_display_mode_properties_khr)(
            physical_device,
            display,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayModeKHR.html>"]
fn vk_create_display_mode_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDisplayModeCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_mode: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDisplayModeKHR({physical_device:?}, {display:?}, {p_create_info:?}, {p_allocator:?}, {p_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_display_mode_khr)(
            physical_device,
            display,
            p_create_info,
            p_allocator,
            p_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_mode);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html>"]
fn vk_get_display_plane_capabilities_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let mode: NonDisposableHandle = packet.read();
    let plane_index: u32 = packet.read();
    let p_capabilities: *mut VkDisplayPlaneCapabilitiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDisplayPlaneCapabilitiesKHR({physical_device:?}, {mode:?}, {plane_index:?}, {p_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_display_plane_capabilities_khr)(
            physical_device,
            mode,
            plane_index,
            p_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDisplayPlaneSurfaceKHR.html>"]
fn vk_create_display_plane_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDisplaySurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDisplayPlaneSurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_display_plane_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSharedSwapchainsKHR.html>"]
fn vk_create_shared_swapchains_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain_count: u32 = packet.read();
    let p_create_infos: *const VkSwapchainCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_swapchains: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateSharedSwapchainsKHR({device:?}, {swapchain_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_swapchains:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_shared_swapchains_khr)(
            device,
            swapchain_count,
            p_create_infos,
            p_allocator,
            p_swapchains,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_swapchains);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroySurfaceKHR.html>"]
fn vk_destroy_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroySurfaceKHR({instance:?}, {surface:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_surface_khr)(
            instance,
            surface,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html>"]
fn vk_get_physical_device_surface_support_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let p_supported: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceSurfaceSupportKHR({physical_device:?}, {queue_family_index:?}, {surface:?}, {p_supported:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_support_khr)(
            physical_device,
            queue_family_index,
            surface,
            p_supported,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_supported);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html>"]
fn vk_get_physical_device_surface_capabilities_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let p_surface_capabilities: *mut VkSurfaceCapabilitiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceSurfaceCapabilitiesKHR({physical_device:?}, {surface:?}, {p_surface_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_capabilities_khr)(
            physical_device,
            surface,
            p_surface_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html>"]
fn vk_get_physical_device_surface_formats_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let (mut p_surface_format_count, p_surface_formats) = packet.read_and_allocate_vk_array_count::<VkSurfaceFormatKHR>();
    trace!("called vkGetPhysicalDeviceSurfaceFormatsKHR({physical_device:?}, {surface:?}, {p_surface_format_count:?}, {p_surface_formats:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_formats_khr)(
            physical_device,
            surface,
            &mut p_surface_format_count,
            p_surface_formats,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_surface_format_count, p_surface_formats);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html>"]
fn vk_get_physical_device_surface_present_modes_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let (mut p_present_mode_count, p_present_modes) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkGetPhysicalDeviceSurfacePresentModesKHR({physical_device:?}, {surface:?}, {p_present_mode_count:?}, {p_present_modes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_present_modes_khr)(
            physical_device,
            surface,
            &mut p_present_mode_count,
            p_present_modes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_present_mode_count, p_present_modes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSwapchainKHR.html>"]
fn vk_create_swapchain_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkSwapchainCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_swapchain: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateSwapchainKHR({device:?}, {p_create_info:?}, {p_allocator:?}, {p_swapchain:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_swapchain_khr)(
            device,
            p_create_info,
            p_allocator,
            p_swapchain,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_swapchain);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroySwapchainKHR.html>"]
fn vk_destroy_swapchain_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroySwapchainKHR({device:?}, {swapchain:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_swapchain_khr)(
            device,
            swapchain,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainImagesKHR.html>"]
fn vk_get_swapchain_images_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let (mut p_swapchain_image_count, p_swapchain_images) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkGetSwapchainImagesKHR({device:?}, {swapchain:?}, {p_swapchain_image_count:?}, {p_swapchain_images:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_swapchain_images_khr)(
            device,
            swapchain,
            &mut p_swapchain_image_count,
            p_swapchain_images,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_swapchain_image_count, p_swapchain_images);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImageKHR.html>"]
fn vk_acquire_next_image_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let timeout: u64 = packet.read();
    let semaphore: NonDisposableHandle = packet.read();
    let fence: NonDisposableHandle = packet.read();
    let p_image_index: *mut u32 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAcquireNextImageKHR({device:?}, {swapchain:?}, {timeout:?}, {semaphore:?}, {fence:?}, {p_image_index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_next_image_khr)(
            device,
            swapchain,
            timeout,
            semaphore,
            fence,
            p_image_index,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_image_index);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueuePresentKHR.html>"]
fn vk_queue_present_khr(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let p_present_info: *const VkPresentInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkQueuePresentKHR({queue:?}, {p_present_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_present_khr)(
            queue,
            p_present_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateViSurfaceNN.html>"]
fn vk_create_vi_surface_nn(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkViSurfaceCreateInfoNN = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateViSurfaceNN({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_vi_surface_nn)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateWaylandSurfaceKHR.html>"]
fn vk_create_wayland_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkWaylandSurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateWaylandSurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_wayland_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceWaylandPresentationSupportKHR.html>"]
fn vk_get_physical_device_wayland_presentation_support_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let display: *mut usize = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceWaylandPresentationSupportKHR({physical_device:?}, {queue_family_index:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_wayland_presentation_support_khr)(
            physical_device,
            queue_family_index,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(display);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateWin32SurfaceKHR.html>"]
fn vk_create_win32_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkWin32SurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateWin32SurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_win32_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceWin32PresentationSupportKHR.html>"]
fn vk_get_physical_device_win32_presentation_support_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    trace!("called vkGetPhysicalDeviceWin32PresentationSupportKHR({physical_device:?}, {queue_family_index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_win32_presentation_support_khr)(
            physical_device,
            queue_family_index,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateXlibSurfaceKHR.html>"]
fn vk_create_xlib_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkXlibSurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateXlibSurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_xlib_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceXlibPresentationSupportKHR.html>"]
fn vk_get_physical_device_xlib_presentation_support_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let dpy: *mut usize = packet.read_nullable_raw_ptr_mut();
    let visual_id: VisualID = packet.read();
    trace!("called vkGetPhysicalDeviceXlibPresentationSupportKHR({physical_device:?}, {queue_family_index:?}, {dpy:?}, {visual_id:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_xlib_presentation_support_khr)(
            physical_device,
            queue_family_index,
            dpy,
            visual_id,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(dpy);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateXcbSurfaceKHR.html>"]
fn vk_create_xcb_surface_khr(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkXcbSurfaceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateXcbSurfaceKHR({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_xcb_surface_khr)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceXcbPresentationSupportKHR.html>"]
fn vk_get_physical_device_xcb_presentation_support_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let connection: *mut usize = packet.read_nullable_raw_ptr_mut();
    let visual_id: xcb_visualid_t = packet.read();
    trace!("called vkGetPhysicalDeviceXcbPresentationSupportKHR({physical_device:?}, {queue_family_index:?}, {connection:?}, {visual_id:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_xcb_presentation_support_khr)(
            physical_device,
            queue_family_index,
            connection,
            visual_id,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(connection);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDirectFBSurfaceEXT.html>"]
fn vk_create_direct_fbsurface_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDirectFBSurfaceCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDirectFBSurfaceEXT({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_direct_fbsurface_ext)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDirectFBPresentationSupportEXT.html>"]
fn vk_get_physical_device_direct_fbpresentation_support_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let dfb: *mut usize = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceDirectFBPresentationSupportEXT({physical_device:?}, {queue_family_index:?}, {dfb:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_direct_fbpresentation_support_ext)(
            physical_device,
            queue_family_index,
            dfb,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(dfb);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateImagePipeSurfaceFUCHSIA.html>"]
fn vk_create_image_pipe_surface_fuchsia(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkImagePipeSurfaceCreateInfoFUCHSIA = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateImagePipeSurfaceFUCHSIA({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_image_pipe_surface_fuchsia)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateStreamDescriptorSurfaceGGP.html>"]
fn vk_create_stream_descriptor_surface_ggp(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkStreamDescriptorSurfaceCreateInfoGGP = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateStreamDescriptorSurfaceGGP({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_stream_descriptor_surface_ggp)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateScreenSurfaceQNX.html>"]
fn vk_create_screen_surface_qnx(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkScreenSurfaceCreateInfoQNX = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateScreenSurfaceQNX({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_screen_surface_qnx)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceScreenPresentationSupportQNX.html>"]
fn vk_get_physical_device_screen_presentation_support_qnx(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let window: *mut usize = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceScreenPresentationSupportQNX({physical_device:?}, {queue_family_index:?}, {window:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_screen_presentation_support_qnx)(
            physical_device,
            queue_family_index,
            window,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(window);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugReportCallbackEXT.html>"]
fn vk_create_debug_report_callback_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDebugReportCallbackCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_callback: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDebugReportCallbackEXT({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_callback:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_debug_report_callback_ext)(
            instance,
            p_create_info,
            p_allocator,
            p_callback,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_callback);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugReportCallbackEXT.html>"]
fn vk_destroy_debug_report_callback_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let callback: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDebugReportCallbackEXT({instance:?}, {callback:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_debug_report_callback_ext)(
            instance,
            callback,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDebugReportMessageEXT.html>"]
fn vk_debug_report_message_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    let object_type: NonDisposableHandle = packet.read();
    let object: u64 = packet.read();
    let location: usize = packet.read();
    let message_code: i32 = packet.read();
    let p_layer_prefix: *const c_char = packet.read_nullable_raw_ptr();
    let p_message: *const c_char = packet.read_nullable_raw_ptr();
    trace!("called vkDebugReportMessageEXT({instance:?}, {flags:?}, {object_type:?}, {object:?}, {location:?}, {message_code:?}, {p_layer_prefix:?}, {p_message:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_debug_report_message_ext)(
            instance,
            flags,
            object_type,
            object,
            location,
            message_code,
            p_layer_prefix,
            p_message,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectNameEXT.html>"]
fn vk_debug_marker_set_object_name_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_name_info: *const VkDebugMarkerObjectNameInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkDebugMarkerSetObjectNameEXT({device:?}, {p_name_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_debug_marker_set_object_name_ext)(
            device,
            p_name_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDebugMarkerSetObjectTagEXT.html>"]
fn vk_debug_marker_set_object_tag_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_tag_info: *const VkDebugMarkerObjectTagInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkDebugMarkerSetObjectTagEXT({device:?}, {p_tag_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_debug_marker_set_object_tag_ext)(
            device,
            p_tag_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerBeginEXT.html>"]
fn vk_cmd_debug_marker_begin_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_marker_info: *const VkDebugMarkerMarkerInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDebugMarkerBeginEXT({command_buffer:?}, {p_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_debug_marker_begin_ext)(
            command_buffer,
            p_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerEndEXT.html>"]
fn vk_cmd_debug_marker_end_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdDebugMarkerEndEXT({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_debug_marker_end_ext)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDebugMarkerInsertEXT.html>"]
fn vk_cmd_debug_marker_insert_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_marker_info: *const VkDebugMarkerMarkerInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDebugMarkerInsertEXT({command_buffer:?}, {p_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_debug_marker_insert_ext)(
            command_buffer,
            p_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html>"]
fn vk_get_physical_device_external_image_format_properties_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let type_: NonDisposableHandle = packet.read();
    let tiling: NonDisposableHandle = packet.read();
    let usage: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    let external_handle_type: NonDisposableHandle = packet.read();
    let p_external_image_format_properties: *mut VkExternalImageFormatPropertiesNV = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceExternalImageFormatPropertiesNV({physical_device:?}, {format:?}, {type_:?}, {tiling:?}, {usage:?}, {flags:?}, {external_handle_type:?}, {p_external_image_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_external_image_format_properties_nv)(
            physical_device,
            format,
            type_,
            tiling,
            usage,
            flags,
            external_handle_type,
            p_external_image_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_external_image_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleNV.html>"]
fn vk_get_memory_win32_handle_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let handle_type: NonDisposableHandle = packet.read();
    let p_handle: *mut vk::HANDLE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryWin32HandleNV({device:?}, {memory:?}, {handle_type:?}, {p_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_win32_handle_nv)(
            device,
            memory,
            handle_type,
            p_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdExecuteGeneratedCommandsNV.html>"]
fn vk_cmd_execute_generated_commands_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let is_preprocessed: NonDisposableHandle = packet.read();
    let p_generated_commands_info: *const VkGeneratedCommandsInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdExecuteGeneratedCommandsNV({command_buffer:?}, {is_preprocessed:?}, {p_generated_commands_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_execute_generated_commands_nv)(
            command_buffer,
            is_preprocessed,
            p_generated_commands_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPreprocessGeneratedCommandsNV.html>"]
fn vk_cmd_preprocess_generated_commands_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_generated_commands_info: *const VkGeneratedCommandsInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPreprocessGeneratedCommandsNV({command_buffer:?}, {p_generated_commands_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_preprocess_generated_commands_nv)(
            command_buffer,
            p_generated_commands_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindPipelineShaderGroupNV.html>"]
fn vk_cmd_bind_pipeline_shader_group_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let group_index: u32 = packet.read();
    trace!("called vkCmdBindPipelineShaderGroupNV({command_buffer:?}, {pipeline_bind_point:?}, {pipeline:?}, {group_index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_pipeline_shader_group_nv)(
            command_buffer,
            pipeline_bind_point,
            pipeline,
            group_index,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetGeneratedCommandsMemoryRequirementsNV.html>"]
fn vk_get_generated_commands_memory_requirements_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkGeneratedCommandsMemoryRequirementsInfoNV = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetGeneratedCommandsMemoryRequirementsNV({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_generated_commands_memory_requirements_nv)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateIndirectCommandsLayoutNV.html>"]
fn vk_create_indirect_commands_layout_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkIndirectCommandsLayoutCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_indirect_commands_layout: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateIndirectCommandsLayoutNV({device:?}, {p_create_info:?}, {p_allocator:?}, {p_indirect_commands_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_indirect_commands_layout_nv)(
            device,
            p_create_info,
            p_allocator,
            p_indirect_commands_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_indirect_commands_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyIndirectCommandsLayoutNV.html>"]
fn vk_destroy_indirect_commands_layout_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let indirect_commands_layout: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyIndirectCommandsLayoutNV({device:?}, {indirect_commands_layout:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_indirect_commands_layout_nv)(
            device,
            indirect_commands_layout,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFeatures2.html>"]
fn vk_get_physical_device_features2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_features: *mut VkPhysicalDeviceFeatures2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceFeatures2({physical_device:?}, {p_features:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_features2)(
            physical_device,
            p_features,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_features);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceProperties2.html>"]
fn vk_get_physical_device_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_properties: *mut VkPhysicalDeviceProperties2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceProperties2({physical_device:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_properties2)(
            physical_device,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html>"]
fn vk_get_physical_device_format_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let p_format_properties: *mut VkFormatProperties2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceFormatProperties2({physical_device:?}, {format:?}, {p_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_format_properties2)(
            physical_device,
            format,
            p_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html>"]
fn vk_get_physical_device_image_format_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_image_format_info: *const VkPhysicalDeviceImageFormatInfo2 = packet.read_nullable_raw_ptr();
    let p_image_format_properties: *mut VkImageFormatProperties2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceImageFormatProperties2({physical_device:?}, {p_image_format_info:?}, {p_image_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_image_format_properties2)(
            physical_device,
            p_image_format_info,
            p_image_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_image_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html>"]
fn vk_get_physical_device_queue_family_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_queue_family_property_count, p_queue_family_properties) = packet.read_and_allocate_vk_array_count::<VkQueueFamilyProperties2>();
    trace!("called vkGetPhysicalDeviceQueueFamilyProperties2({physical_device:?}, {p_queue_family_property_count:?}, {p_queue_family_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_queue_family_properties2)(
            physical_device,
            &mut p_queue_family_property_count,
            p_queue_family_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_queue_family_property_count, p_queue_family_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html>"]
fn vk_get_physical_device_memory_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_memory_properties: *mut VkPhysicalDeviceMemoryProperties2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceMemoryProperties2({physical_device:?}, {p_memory_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_memory_properties2)(
            physical_device,
            p_memory_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html>"]
fn vk_get_physical_device_sparse_image_format_properties2(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_format_info: *const VkPhysicalDeviceSparseImageFormatInfo2 = packet.read_nullable_raw_ptr();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkSparseImageFormatProperties2>();
    trace!("called vkGetPhysicalDeviceSparseImageFormatProperties2({physical_device:?}, {p_format_info:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_sparse_image_format_properties2)(
            physical_device,
            p_format_info,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetKHR.html>"]
fn vk_cmd_push_descriptor_set_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let set: u32 = packet.read();
    let descriptor_write_count: u32 = packet.read();
    let p_descriptor_writes: *const VkWriteDescriptorSet = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushDescriptorSetKHR({command_buffer:?}, {pipeline_bind_point:?}, {layout:?}, {set:?}, {descriptor_write_count:?}, {p_descriptor_writes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_descriptor_set_khr)(
            command_buffer,
            pipeline_bind_point,
            layout,
            set,
            descriptor_write_count,
            p_descriptor_writes,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkTrimCommandPool.html>"]
fn vk_trim_command_pool(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let command_pool: NonDisposableHandle = packet.read();
    let flags: NonDisposableHandle = packet.read();
    trace!("called vkTrimCommandPool({device:?}, {command_pool:?}, {flags:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_trim_command_pool)(
            device,
            command_pool,
            flags,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html>"]
fn vk_get_physical_device_external_buffer_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_external_buffer_info: *const VkPhysicalDeviceExternalBufferInfo = packet.read_nullable_raw_ptr();
    let p_external_buffer_properties: *mut VkExternalBufferProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceExternalBufferProperties({physical_device:?}, {p_external_buffer_info:?}, {p_external_buffer_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_external_buffer_properties)(
            physical_device,
            p_external_buffer_info,
            p_external_buffer_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_external_buffer_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandleKHR.html>"]
fn vk_get_memory_win32_handle_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_win32_handle_info: *const VkMemoryGetWin32HandleInfoKHR = packet.read_nullable_raw_ptr();
    let p_handle: *mut vk::HANDLE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryWin32HandleKHR({device:?}, {p_get_win32_handle_info:?}, {p_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_win32_handle_khr)(
            device,
            p_get_win32_handle_info,
            p_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryWin32HandlePropertiesKHR.html>"]
fn vk_get_memory_win32_handle_properties_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let handle_type: vk::ExternalMemoryHandleTypeFlags = packet.read();
    let handle: vk::HANDLE = packet.read();
    let p_memory_win32_handle_properties: *mut VkMemoryWin32HandlePropertiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryWin32HandlePropertiesKHR({device:?}, {handle_type:?}, {handle:?}, {p_memory_win32_handle_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_win32_handle_properties_khr)(
            device,
            handle_type,
            handle,
            p_memory_win32_handle_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_win32_handle_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdKHR.html>"]
fn vk_get_memory_fd_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_fd_info: *const VkMemoryGetFdInfoKHR = packet.read_nullable_raw_ptr();
    let p_fd: *mut std::os::raw::c_int = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryFdKHR({device:?}, {p_get_fd_info:?}, {p_fd:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_fd_khr)(
            device,
            p_get_fd_info,
            p_fd,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fd);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryFdPropertiesKHR.html>"]
fn vk_get_memory_fd_properties_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let handle_type: vk::ExternalMemoryHandleTypeFlags = packet.read();
    let fd: std::os::raw::c_int = packet.read();
    let p_memory_fd_properties: *mut VkMemoryFdPropertiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryFdPropertiesKHR({device:?}, {handle_type:?}, {fd:?}, {p_memory_fd_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_fd_properties_khr)(
            device,
            handle_type,
            fd,
            p_memory_fd_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_fd_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryZirconHandleFUCHSIA.html>"]
fn vk_get_memory_zircon_handle_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_zircon_handle_info: *const VkMemoryGetZirconHandleInfoFUCHSIA = packet.read_nullable_raw_ptr();
    let p_zircon_handle: *mut vk::zx_handle_t = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryZirconHandleFUCHSIA({device:?}, {p_get_zircon_handle_info:?}, {p_zircon_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_zircon_handle_fuchsia)(
            device,
            p_get_zircon_handle_info,
            p_zircon_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_zircon_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryZirconHandlePropertiesFUCHSIA.html>"]
fn vk_get_memory_zircon_handle_properties_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let handle_type: vk::ExternalMemoryHandleTypeFlags = packet.read();
    let zircon_handle: vk::zx_handle_t = packet.read();
    let p_memory_zircon_handle_properties: *mut VkMemoryZirconHandlePropertiesFUCHSIA = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryZirconHandlePropertiesFUCHSIA({device:?}, {handle_type:?}, {zircon_handle:?}, {p_memory_zircon_handle_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_zircon_handle_properties_fuchsia)(
            device,
            handle_type,
            zircon_handle,
            p_memory_zircon_handle_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_zircon_handle_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryRemoteAddressNV.html>"]
fn vk_get_memory_remote_address_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_memory_get_remote_address_info: *const VkMemoryGetRemoteAddressInfoNV = packet.read_nullable_raw_ptr();
    let p_address: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryRemoteAddressNV({device:?}, {p_memory_get_remote_address_info:?}, {p_address:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_remote_address_nv)(
            device,
            p_memory_get_remote_address_info,
            p_address,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_address);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html>"]
fn vk_get_physical_device_external_semaphore_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_external_semaphore_info: *const VkPhysicalDeviceExternalSemaphoreInfo = packet.read_nullable_raw_ptr();
    let p_external_semaphore_properties: *mut VkExternalSemaphoreProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceExternalSemaphoreProperties({physical_device:?}, {p_external_semaphore_info:?}, {p_external_semaphore_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_external_semaphore_properties)(
            physical_device,
            p_external_semaphore_info,
            p_external_semaphore_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_external_semaphore_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreWin32HandleKHR.html>"]
fn vk_get_semaphore_win32_handle_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_win32_handle_info: *const VkSemaphoreGetWin32HandleInfoKHR = packet.read_nullable_raw_ptr();
    let p_handle: *mut vk::HANDLE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSemaphoreWin32HandleKHR({device:?}, {p_get_win32_handle_info:?}, {p_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_semaphore_win32_handle_khr)(
            device,
            p_get_win32_handle_info,
            p_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreWin32HandleKHR.html>"]
fn vk_import_semaphore_win32_handle_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_import_semaphore_win32_handle_info: *const VkImportSemaphoreWin32HandleInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkImportSemaphoreWin32HandleKHR({device:?}, {p_import_semaphore_win32_handle_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_import_semaphore_win32_handle_khr)(
            device,
            p_import_semaphore_win32_handle_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreFdKHR.html>"]
fn vk_get_semaphore_fd_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_fd_info: *const VkSemaphoreGetFdInfoKHR = packet.read_nullable_raw_ptr();
    let p_fd: *mut std::os::raw::c_int = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSemaphoreFdKHR({device:?}, {p_get_fd_info:?}, {p_fd:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_semaphore_fd_khr)(
            device,
            p_get_fd_info,
            p_fd,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fd);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreFdKHR.html>"]
fn vk_import_semaphore_fd_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_import_semaphore_fd_info: *const VkImportSemaphoreFdInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkImportSemaphoreFdKHR({device:?}, {p_import_semaphore_fd_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_import_semaphore_fd_khr)(
            device,
            p_import_semaphore_fd_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreZirconHandleFUCHSIA.html>"]
fn vk_get_semaphore_zircon_handle_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_zircon_handle_info: *const VkSemaphoreGetZirconHandleInfoFUCHSIA = packet.read_nullable_raw_ptr();
    let p_zircon_handle: *mut vk::zx_handle_t = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSemaphoreZirconHandleFUCHSIA({device:?}, {p_get_zircon_handle_info:?}, {p_zircon_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_semaphore_zircon_handle_fuchsia)(
            device,
            p_get_zircon_handle_info,
            p_zircon_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_zircon_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkImportSemaphoreZirconHandleFUCHSIA.html>"]
fn vk_import_semaphore_zircon_handle_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_import_semaphore_zircon_handle_info: *const VkImportSemaphoreZirconHandleInfoFUCHSIA = packet.read_nullable_raw_ptr();
    trace!("called vkImportSemaphoreZirconHandleFUCHSIA({device:?}, {p_import_semaphore_zircon_handle_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_import_semaphore_zircon_handle_fuchsia)(
            device,
            p_import_semaphore_zircon_handle_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html>"]
fn vk_get_physical_device_external_fence_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_external_fence_info: *const VkPhysicalDeviceExternalFenceInfo = packet.read_nullable_raw_ptr();
    let p_external_fence_properties: *mut VkExternalFenceProperties = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceExternalFenceProperties({physical_device:?}, {p_external_fence_info:?}, {p_external_fence_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_external_fence_properties)(
            physical_device,
            p_external_fence_info,
            p_external_fence_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_external_fence_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetFenceWin32HandleKHR.html>"]
fn vk_get_fence_win32_handle_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_win32_handle_info: *const VkFenceGetWin32HandleInfoKHR = packet.read_nullable_raw_ptr();
    let p_handle: *mut vk::HANDLE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetFenceWin32HandleKHR({device:?}, {p_get_win32_handle_info:?}, {p_handle:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_fence_win32_handle_khr)(
            device,
            p_get_win32_handle_info,
            p_handle,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_handle);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkImportFenceWin32HandleKHR.html>"]
fn vk_import_fence_win32_handle_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_import_fence_win32_handle_info: *const VkImportFenceWin32HandleInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkImportFenceWin32HandleKHR({device:?}, {p_import_fence_win32_handle_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_import_fence_win32_handle_khr)(
            device,
            p_import_fence_win32_handle_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetFenceFdKHR.html>"]
fn vk_get_fence_fd_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_get_fd_info: *const VkFenceGetFdInfoKHR = packet.read_nullable_raw_ptr();
    let p_fd: *mut std::os::raw::c_int = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetFenceFdKHR({device:?}, {p_get_fd_info:?}, {p_fd:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_fence_fd_khr)(
            device,
            p_get_fd_info,
            p_fd,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fd);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkImportFenceFdKHR.html>"]
fn vk_import_fence_fd_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_import_fence_fd_info: *const VkImportFenceFdInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkImportFenceFdKHR({device:?}, {p_import_fence_fd_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_import_fence_fd_khr)(
            device,
            p_import_fence_fd_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkReleaseDisplayEXT.html>"]
fn vk_release_display_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    trace!("called vkReleaseDisplayEXT({physical_device:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_release_display_ext)(
            physical_device,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireXlibDisplayEXT.html>"]
fn vk_acquire_xlib_display_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let dpy: *mut usize = packet.read_nullable_raw_ptr_mut();
    let display: NonDisposableHandle = packet.read();
    trace!("called vkAcquireXlibDisplayEXT({physical_device:?}, {dpy:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_xlib_display_ext)(
            physical_device,
            dpy,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(dpy);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRandROutputDisplayEXT.html>"]
fn vk_get_rand_routput_display_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let dpy: *mut usize = packet.read_nullable_raw_ptr_mut();
    let rr_output: RROutput = packet.read();
    let p_display: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRandROutputDisplayEXT({physical_device:?}, {dpy:?}, {rr_output:?}, {p_display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_rand_routput_display_ext)(
            physical_device,
            dpy,
            rr_output,
            p_display,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(dpy);
    response.write_raw_ptr(p_display);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireWinrtDisplayNV.html>"]
fn vk_acquire_winrt_display_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    trace!("called vkAcquireWinrtDisplayNV({physical_device:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_winrt_display_nv)(
            physical_device,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetWinrtDisplayNV.html>"]
fn vk_get_winrt_display_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let device_relative_id: u32 = packet.read();
    let p_display: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetWinrtDisplayNV({physical_device:?}, {device_relative_id:?}, {p_display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_winrt_display_nv)(
            physical_device,
            device_relative_id,
            p_display,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_display);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDisplayPowerControlEXT.html>"]
fn vk_display_power_control_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    let p_display_power_info: *const VkDisplayPowerInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkDisplayPowerControlEXT({device:?}, {display:?}, {p_display_power_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_display_power_control_ext)(
            device,
            display,
            p_display_power_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkRegisterDeviceEventEXT.html>"]
fn vk_register_device_event_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_device_event_info: *const VkDeviceEventInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_fence: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkRegisterDeviceEventEXT({device:?}, {p_device_event_info:?}, {p_allocator:?}, {p_fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_register_device_event_ext)(
            device,
            p_device_event_info,
            p_allocator,
            p_fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fence);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkRegisterDisplayEventEXT.html>"]
fn vk_register_display_event_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    let p_display_event_info: *const VkDisplayEventInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_fence: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkRegisterDisplayEventEXT({device:?}, {display:?}, {p_display_event_info:?}, {p_allocator:?}, {p_fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_register_display_event_ext)(
            device,
            display,
            p_display_event_info,
            p_allocator,
            p_fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fence);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainCounterEXT.html>"]
fn vk_get_swapchain_counter_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let counter: vk::SurfaceCounterFlagsEXT = packet.read();
    let p_counter_value: *mut u64 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSwapchainCounterEXT({device:?}, {swapchain:?}, {counter:?}, {p_counter_value:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_swapchain_counter_ext)(
            device,
            swapchain,
            counter,
            p_counter_value,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_counter_value);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html>"]
fn vk_get_physical_device_surface_capabilities2_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let p_surface_capabilities: *mut VkSurfaceCapabilities2EXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceSurfaceCapabilities2EXT({physical_device:?}, {surface:?}, {p_surface_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_capabilities2_ext)(
            physical_device,
            surface,
            p_surface_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceGroups.html>"]
fn vk_enumerate_physical_device_groups(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let (mut p_physical_device_group_count, p_physical_device_group_properties) = packet.read_and_allocate_vk_array_count::<VkPhysicalDeviceGroupProperties>();
    trace!("called vkEnumeratePhysicalDeviceGroups({instance:?}, {p_physical_device_group_count:?}, {p_physical_device_group_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_physical_device_groups)(
            instance,
            &mut p_physical_device_group_count,
            p_physical_device_group_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_physical_device_group_count, p_physical_device_group_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPeerMemoryFeatures.html>"]
fn vk_get_device_group_peer_memory_features(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let heap_index: u32 = packet.read();
    let local_device_index: u32 = packet.read();
    let remote_device_index: u32 = packet.read();
    let p_peer_memory_features: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceGroupPeerMemoryFeatures({device:?}, {heap_index:?}, {local_device_index:?}, {remote_device_index:?}, {p_peer_memory_features:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_group_peer_memory_features)(
            device,
            heap_index,
            local_device_index,
            remote_device_index,
            p_peer_memory_features,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_peer_memory_features);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindBufferMemory2.html>"]
fn vk_bind_buffer_memory2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let bind_info_count: u32 = packet.read();
    let p_bind_infos: *const VkBindBufferMemoryInfo = packet.read_nullable_raw_ptr();
    trace!("called vkBindBufferMemory2({device:?}, {bind_info_count:?}, {p_bind_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_buffer_memory2)(
            device,
            bind_info_count,
            p_bind_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindImageMemory2.html>"]
fn vk_bind_image_memory2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let bind_info_count: u32 = packet.read();
    let p_bind_infos: *const VkBindImageMemoryInfo = packet.read_nullable_raw_ptr();
    trace!("called vkBindImageMemory2({device:?}, {bind_info_count:?}, {p_bind_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_image_memory2)(
            device,
            bind_info_count,
            p_bind_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDeviceMask.html>"]
fn vk_cmd_set_device_mask(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let device_mask: u32 = packet.read();
    trace!("called vkCmdSetDeviceMask({command_buffer:?}, {device_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_device_mask)(
            command_buffer,
            device_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupPresentCapabilitiesKHR.html>"]
fn vk_get_device_group_present_capabilities_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_device_group_present_capabilities: *mut VkDeviceGroupPresentCapabilitiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceGroupPresentCapabilitiesKHR({device:?}, {p_device_group_present_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_group_present_capabilities_khr)(
            device,
            p_device_group_present_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_device_group_present_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModesKHR.html>"]
fn vk_get_device_group_surface_present_modes_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let p_modes: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceGroupSurfacePresentModesKHR({device:?}, {surface:?}, {p_modes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_group_surface_present_modes_khr)(
            device,
            surface,
            p_modes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_modes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireNextImage2KHR.html>"]
fn vk_acquire_next_image2_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_acquire_info: *const VkAcquireNextImageInfoKHR = packet.read_nullable_raw_ptr();
    let p_image_index: *mut u32 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAcquireNextImage2KHR({device:?}, {p_acquire_info:?}, {p_image_index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_next_image2_khr)(
            device,
            p_acquire_info,
            p_image_index,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_image_index);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchBase.html>"]
fn vk_cmd_dispatch_base(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let base_group_x: u32 = packet.read();
    let base_group_y: u32 = packet.read();
    let base_group_z: u32 = packet.read();
    let group_count_x: u32 = packet.read();
    let group_count_y: u32 = packet.read();
    let group_count_z: u32 = packet.read();
    trace!("called vkCmdDispatchBase({command_buffer:?}, {base_group_x:?}, {base_group_y:?}, {base_group_z:?}, {group_count_x:?}, {group_count_y:?}, {group_count_z:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch_base)(
            command_buffer,
            base_group_x,
            base_group_y,
            base_group_z,
            group_count_x,
            group_count_y,
            group_count_z,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html>"]
fn vk_get_physical_device_present_rectangles_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let surface: NonDisposableHandle = packet.read();
    let (mut p_rect_count, p_rects) = packet.read_and_allocate_vk_array_count::<VkRect2D>();
    trace!("called vkGetPhysicalDevicePresentRectanglesKHR({physical_device:?}, {surface:?}, {p_rect_count:?}, {p_rects:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_present_rectangles_khr)(
            physical_device,
            surface,
            &mut p_rect_count,
            p_rects,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_rect_count, p_rects);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDescriptorUpdateTemplate.html>"]
fn vk_create_descriptor_update_template(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDescriptorUpdateTemplateCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_descriptor_update_template: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDescriptorUpdateTemplate({device:?}, {p_create_info:?}, {p_allocator:?}, {p_descriptor_update_template:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_descriptor_update_template)(
            device,
            p_create_info,
            p_allocator,
            p_descriptor_update_template,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_descriptor_update_template);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDescriptorUpdateTemplate.html>"]
fn vk_destroy_descriptor_update_template(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_update_template: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDescriptorUpdateTemplate({device:?}, {descriptor_update_template:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_descriptor_update_template)(
            device,
            descriptor_update_template,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUpdateDescriptorSetWithTemplate.html>"]
fn vk_update_descriptor_set_with_template(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_set: NonDisposableHandle = packet.read();
    let descriptor_update_template: NonDisposableHandle = packet.read();
    let p_data: *const c_void = packet.read_nullable_raw_ptr();
    trace!("called vkUpdateDescriptorSetWithTemplate({device:?}, {descriptor_set:?}, {descriptor_update_template:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_update_descriptor_set_with_template)(
            device,
            descriptor_set,
            descriptor_update_template,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplateKHR.html>"]
fn vk_cmd_push_descriptor_set_with_template_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let descriptor_update_template: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let set: u32 = packet.read();
    let p_data: *const c_void = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushDescriptorSetWithTemplateKHR({command_buffer:?}, {descriptor_update_template:?}, {layout:?}, {set:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_descriptor_set_with_template_khr)(
            command_buffer,
            descriptor_update_template,
            layout,
            set,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetHdrMetadataEXT.html>"]
fn vk_set_hdr_metadata_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain_count: u32 = packet.read();
    let p_swapchains: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_metadata: *const VkHdrMetadataEXT = packet.read_nullable_raw_ptr();
    trace!("called vkSetHdrMetadataEXT({device:?}, {swapchain_count:?}, {p_swapchains:?}, {p_metadata:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_hdr_metadata_ext)(
            device,
            swapchain_count,
            p_swapchains,
            p_metadata,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainStatusKHR.html>"]
fn vk_get_swapchain_status_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    trace!("called vkGetSwapchainStatusKHR({device:?}, {swapchain:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_swapchain_status_khr)(
            device,
            swapchain,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRefreshCycleDurationGOOGLE.html>"]
fn vk_get_refresh_cycle_duration_google(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_display_timing_properties: *mut VkRefreshCycleDurationGOOGLE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRefreshCycleDurationGOOGLE({device:?}, {swapchain:?}, {p_display_timing_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_refresh_cycle_duration_google)(
            device,
            swapchain,
            p_display_timing_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_display_timing_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPastPresentationTimingGOOGLE.html>"]
fn vk_get_past_presentation_timing_google(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let (mut p_presentation_timing_count, p_presentation_timings) = packet.read_and_allocate_vk_array_count::<VkPastPresentationTimingGOOGLE>();
    trace!("called vkGetPastPresentationTimingGOOGLE({device:?}, {swapchain:?}, {p_presentation_timing_count:?}, {p_presentation_timings:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_past_presentation_timing_google)(
            device,
            swapchain,
            &mut p_presentation_timing_count,
            p_presentation_timings,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_presentation_timing_count, p_presentation_timings);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateIOSSurfaceMVK.html>"]
fn vk_create_iossurface_mvk(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkIOSSurfaceCreateInfoMVK = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateIOSSurfaceMVK({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_iossurface_mvk)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateMacOSSurfaceMVK.html>"]
fn vk_create_mac_ossurface_mvk(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkMacOSSurfaceCreateInfoMVK = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateMacOSSurfaceMVK({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_mac_ossurface_mvk)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateMetalSurfaceEXT.html>"]
fn vk_create_metal_surface_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkMetalSurfaceCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateMetalSurfaceEXT({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_metal_surface_ext)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingNV.html>"]
fn vk_cmd_set_viewport_wscaling_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_viewport: u32 = packet.read();
    let viewport_count: u32 = packet.read();
    let p_viewport_wscalings: *const VkViewportWScalingNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetViewportWScalingNV({command_buffer:?}, {first_viewport:?}, {viewport_count:?}, {p_viewport_wscalings:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport_wscaling_nv)(
            command_buffer,
            first_viewport,
            viewport_count,
            p_viewport_wscalings,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEXT.html>"]
fn vk_cmd_set_discard_rectangle_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_discard_rectangle: u32 = packet.read();
    let discard_rectangle_count: u32 = packet.read();
    let p_discard_rectangles: *const VkRect2D = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetDiscardRectangleEXT({command_buffer:?}, {first_discard_rectangle:?}, {discard_rectangle_count:?}, {p_discard_rectangles:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_discard_rectangle_ext)(
            command_buffer,
            first_discard_rectangle,
            discard_rectangle_count,
            p_discard_rectangles,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleEnableEXT.html>"]
fn vk_cmd_set_discard_rectangle_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let discard_rectangle_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDiscardRectangleEnableEXT({command_buffer:?}, {discard_rectangle_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_discard_rectangle_enable_ext)(
            command_buffer,
            discard_rectangle_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDiscardRectangleModeEXT.html>"]
fn vk_cmd_set_discard_rectangle_mode_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let discard_rectangle_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDiscardRectangleModeEXT({command_buffer:?}, {discard_rectangle_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_discard_rectangle_mode_ext)(
            command_buffer,
            discard_rectangle_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEXT.html>"]
fn vk_cmd_set_sample_locations_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_sample_locations_info: *const VkSampleLocationsInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetSampleLocationsEXT({command_buffer:?}, {p_sample_locations_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_sample_locations_ext)(
            command_buffer,
            p_sample_locations_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html>"]
fn vk_get_physical_device_multisample_properties_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let samples: vk::SampleCountFlags = packet.read();
    let p_multisample_properties: *mut VkMultisamplePropertiesEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceMultisamplePropertiesEXT({physical_device:?}, {samples:?}, {p_multisample_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_multisample_properties_ext)(
            physical_device,
            samples,
            p_multisample_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_multisample_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html>"]
fn vk_get_physical_device_surface_capabilities2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_surface_info: *const VkPhysicalDeviceSurfaceInfo2KHR = packet.read_nullable_raw_ptr();
    let p_surface_capabilities: *mut VkSurfaceCapabilities2KHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceSurfaceCapabilities2KHR({physical_device:?}, {p_surface_info:?}, {p_surface_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_capabilities2_khr)(
            physical_device,
            p_surface_info,
            p_surface_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html>"]
fn vk_get_physical_device_surface_formats2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_surface_info: *const VkPhysicalDeviceSurfaceInfo2KHR = packet.read_nullable_raw_ptr();
    let (mut p_surface_format_count, p_surface_formats) = packet.read_and_allocate_vk_array_count::<VkSurfaceFormat2KHR>();
    trace!("called vkGetPhysicalDeviceSurfaceFormats2KHR({physical_device:?}, {p_surface_info:?}, {p_surface_format_count:?}, {p_surface_formats:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_formats2_khr)(
            physical_device,
            p_surface_info,
            &mut p_surface_format_count,
            p_surface_formats,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_surface_format_count, p_surface_formats);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html>"]
fn vk_get_physical_device_display_properties2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayProperties2KHR>();
    trace!("called vkGetPhysicalDeviceDisplayProperties2KHR({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_display_properties2_khr)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html>"]
fn vk_get_physical_device_display_plane_properties2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayPlaneProperties2KHR>();
    trace!("called vkGetPhysicalDeviceDisplayPlaneProperties2KHR({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_display_plane_properties2_khr)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDisplayModeProperties2KHR.html>"]
fn vk_get_display_mode_properties2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let display: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkDisplayModeProperties2KHR>();
    trace!("called vkGetDisplayModeProperties2KHR({physical_device:?}, {display:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_display_mode_properties2_khr)(
            physical_device,
            display,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html>"]
fn vk_get_display_plane_capabilities2_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_display_plane_info: *const VkDisplayPlaneInfo2KHR = packet.read_nullable_raw_ptr();
    let p_capabilities: *mut VkDisplayPlaneCapabilities2KHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDisplayPlaneCapabilities2KHR({physical_device:?}, {p_display_plane_info:?}, {p_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_display_plane_capabilities2_khr)(
            physical_device,
            p_display_plane_info,
            p_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferMemoryRequirements2.html>"]
fn vk_get_buffer_memory_requirements2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkBufferMemoryRequirementsInfo2 = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetBufferMemoryRequirements2({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_memory_requirements2)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageMemoryRequirements2.html>"]
fn vk_get_image_memory_requirements2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkImageMemoryRequirementsInfo2 = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageMemoryRequirements2({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_memory_requirements2)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageSparseMemoryRequirements2.html>"]
fn vk_get_image_sparse_memory_requirements2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkImageSparseMemoryRequirementsInfo2 = packet.read_nullable_raw_ptr();
    let (mut p_sparse_memory_requirement_count, p_sparse_memory_requirements) = packet.read_and_allocate_vk_array_count::<VkSparseImageMemoryRequirements2>();
    trace!("called vkGetImageSparseMemoryRequirements2({device:?}, {p_info:?}, {p_sparse_memory_requirement_count:?}, {p_sparse_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_sparse_memory_requirements2)(
            device,
            p_info,
            &mut p_sparse_memory_requirement_count,
            p_sparse_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceBufferMemoryRequirements.html>"]
fn vk_get_device_buffer_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkDeviceBufferMemoryRequirements = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceBufferMemoryRequirements({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_buffer_memory_requirements)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageMemoryRequirements.html>"]
fn vk_get_device_image_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkDeviceImageMemoryRequirements = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceImageMemoryRequirements({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_image_memory_requirements)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSparseMemoryRequirements.html>"]
fn vk_get_device_image_sparse_memory_requirements(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkDeviceImageMemoryRequirements = packet.read_nullable_raw_ptr();
    let (mut p_sparse_memory_requirement_count, p_sparse_memory_requirements) = packet.read_and_allocate_vk_array_count::<VkSparseImageMemoryRequirements2>();
    trace!("called vkGetDeviceImageSparseMemoryRequirements({device:?}, {p_info:?}, {p_sparse_memory_requirement_count:?}, {p_sparse_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_image_sparse_memory_requirements)(
            device,
            p_info,
            &mut p_sparse_memory_requirement_count,
            p_sparse_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_sparse_memory_requirement_count, p_sparse_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateSamplerYcbcrConversion.html>"]
fn vk_create_sampler_ycbcr_conversion(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkSamplerYcbcrConversionCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_ycbcr_conversion: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateSamplerYcbcrConversion({device:?}, {p_create_info:?}, {p_allocator:?}, {p_ycbcr_conversion:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_sampler_ycbcr_conversion)(
            device,
            p_create_info,
            p_allocator,
            p_ycbcr_conversion,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_ycbcr_conversion);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroySamplerYcbcrConversion.html>"]
fn vk_destroy_sampler_ycbcr_conversion(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let ycbcr_conversion: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroySamplerYcbcrConversion({device:?}, {ycbcr_conversion:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_sampler_ycbcr_conversion)(
            device,
            ycbcr_conversion,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceQueue2.html>"]
fn vk_get_device_queue2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_queue_info: *const VkDeviceQueueInfo2 = packet.read_nullable_raw_ptr();
    let p_queue: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceQueue2({device:?}, {p_queue_info:?}, {p_queue:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_queue2)(
            device,
            p_queue_info,
            p_queue,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_queue);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateValidationCacheEXT.html>"]
fn vk_create_validation_cache_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkValidationCacheCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_validation_cache: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateValidationCacheEXT({device:?}, {p_create_info:?}, {p_allocator:?}, {p_validation_cache:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_validation_cache_ext)(
            device,
            p_create_info,
            p_allocator,
            p_validation_cache,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_validation_cache);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyValidationCacheEXT.html>"]
fn vk_destroy_validation_cache_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let validation_cache: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyValidationCacheEXT({device:?}, {validation_cache:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_validation_cache_ext)(
            device,
            validation_cache,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetValidationCacheDataEXT.html>"]
fn vk_get_validation_cache_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let validation_cache: NonDisposableHandle = packet.read();
    let p_data_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetValidationCacheDataEXT({device:?}, {validation_cache:?}, {p_data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_validation_cache_data_ext)(
            device,
            validation_cache,
            p_data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data_size);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMergeValidationCachesEXT.html>"]
fn vk_merge_validation_caches_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let dst_cache: NonDisposableHandle = packet.read();
    let src_cache_count: u32 = packet.read();
    let p_src_caches: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkMergeValidationCachesEXT({device:?}, {dst_cache:?}, {src_cache_count:?}, {p_src_caches:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_merge_validation_caches_ext)(
            device,
            dst_cache,
            src_cache_count,
            p_src_caches,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSupport.html>"]
fn vk_get_descriptor_set_layout_support(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDescriptorSetLayoutCreateInfo = packet.read_nullable_raw_ptr();
    let p_support: *mut VkDescriptorSetLayoutSupport = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorSetLayoutSupport({device:?}, {p_create_info:?}, {p_support:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_set_layout_support)(
            device,
            p_create_info,
            p_support,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_support);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainGrallocUsageANDROID.html>"]
fn vk_get_swapchain_gralloc_usage_android(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let image_usage: NonDisposableHandle = packet.read();
    let gralloc_usage: *mut std::os::raw::c_int = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSwapchainGrallocUsageANDROID({device:?}, {format:?}, {image_usage:?}, {gralloc_usage:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_swapchain_gralloc_usage_android)(
            device,
            format,
            image_usage,
            gralloc_usage,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(gralloc_usage);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSwapchainGrallocUsage2ANDROID.html>"]
fn vk_get_swapchain_gralloc_usage2_android(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let format: NonDisposableHandle = packet.read();
    let image_usage: NonDisposableHandle = packet.read();
    let swapchain_image_usage: NonDisposableHandle = packet.read();
    let gralloc_consumer_usage: *mut u64 = packet.read_nullable_raw_ptr_mut();
    let gralloc_producer_usage: *mut u64 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSwapchainGrallocUsage2ANDROID({device:?}, {format:?}, {image_usage:?}, {swapchain_image_usage:?}, {gralloc_consumer_usage:?}, {gralloc_producer_usage:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_swapchain_gralloc_usage2_android)(
            device,
            format,
            image_usage,
            swapchain_image_usage,
            gralloc_consumer_usage,
            gralloc_producer_usage,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(gralloc_consumer_usage);
    response.write_raw_ptr(gralloc_producer_usage);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireImageANDROID.html>"]
fn vk_acquire_image_android(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let native_fence_fd: std::os::raw::c_int = packet.read();
    let semaphore: NonDisposableHandle = packet.read();
    let fence: NonDisposableHandle = packet.read();
    trace!("called vkAcquireImageANDROID({device:?}, {image:?}, {native_fence_fd:?}, {semaphore:?}, {fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_image_android)(
            device,
            image,
            native_fence_fd,
            semaphore,
            fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSignalReleaseImageANDROID.html>"]
fn vk_queue_signal_release_image_android(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let wait_semaphore_count: u32 = packet.read();
    let p_wait_semaphores: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let image: NonDisposableHandle = packet.read();
    let p_native_fence_fd: *mut std::os::raw::c_int = packet.read_nullable_raw_ptr_mut();
    trace!("called vkQueueSignalReleaseImageANDROID({queue:?}, {wait_semaphore_count:?}, {p_wait_semaphores:?}, {image:?}, {p_native_fence_fd:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_signal_release_image_android)(
            queue,
            wait_semaphore_count,
            p_wait_semaphores,
            image,
            p_native_fence_fd,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_native_fence_fd);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetShaderInfoAMD.html>"]
fn vk_get_shader_info_amd(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let shader_stage: vk::ShaderStageFlags = packet.read();
    let info_type: NonDisposableHandle = packet.read();
    let p_info_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_info: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetShaderInfoAMD({device:?}, {pipeline:?}, {shader_stage:?}, {info_type:?}, {p_info_size:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_shader_info_amd)(
            device,
            pipeline,
            shader_stage,
            info_type,
            p_info_size,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_info_size);
    response.write_raw_ptr(p_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetLocalDimmingAMD.html>"]
fn vk_set_local_dimming_amd(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swap_chain: NonDisposableHandle = packet.read();
    let local_dimming_enable: NonDisposableHandle = packet.read();
    trace!("called vkSetLocalDimmingAMD({device:?}, {swap_chain:?}, {local_dimming_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_local_dimming_amd)(
            device,
            swap_chain,
            local_dimming_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsKHR.html>"]
fn vk_get_physical_device_calibrateable_time_domains_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_time_domain_count, p_time_domains) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkGetPhysicalDeviceCalibrateableTimeDomainsKHR({physical_device:?}, {p_time_domain_count:?}, {p_time_domains:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_calibrateable_time_domains_khr)(
            physical_device,
            &mut p_time_domain_count,
            p_time_domains,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_time_domain_count, p_time_domains);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetCalibratedTimestampsKHR.html>"]
fn vk_get_calibrated_timestamps_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let timestamp_count: u32 = packet.read();
    let p_timestamp_infos: *const VkCalibratedTimestampInfoKHR = packet.read_nullable_raw_ptr();
    let p_timestamps: *mut u64 = packet.read_nullable_raw_ptr_mut();
    let p_max_deviation: *mut u64 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetCalibratedTimestampsKHR({device:?}, {timestamp_count:?}, {p_timestamp_infos:?}, {p_timestamps:?}, {p_max_deviation:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_calibrated_timestamps_khr)(
            device,
            timestamp_count,
            p_timestamp_infos,
            p_timestamps,
            p_max_deviation,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_timestamps);
    response.write_raw_ptr(p_max_deviation);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectNameEXT.html>"]
fn vk_set_debug_utils_object_name_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_name_info: *const VkDebugUtilsObjectNameInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkSetDebugUtilsObjectNameEXT({device:?}, {p_name_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_debug_utils_object_name_ext)(
            device,
            p_name_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetDebugUtilsObjectTagEXT.html>"]
fn vk_set_debug_utils_object_tag_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_tag_info: *const VkDebugUtilsObjectTagInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkSetDebugUtilsObjectTagEXT({device:?}, {p_tag_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_debug_utils_object_tag_ext)(
            device,
            p_tag_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueBeginDebugUtilsLabelEXT.html>"]
fn vk_queue_begin_debug_utils_label_ext(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let p_label_info: *const VkDebugUtilsLabelEXT = packet.read_nullable_raw_ptr();
    trace!("called vkQueueBeginDebugUtilsLabelEXT({queue:?}, {p_label_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_begin_debug_utils_label_ext)(
            queue,
            p_label_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueEndDebugUtilsLabelEXT.html>"]
fn vk_queue_end_debug_utils_label_ext(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    trace!("called vkQueueEndDebugUtilsLabelEXT({queue:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_end_debug_utils_label_ext)(
            queue,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueInsertDebugUtilsLabelEXT.html>"]
fn vk_queue_insert_debug_utils_label_ext(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let p_label_info: *const VkDebugUtilsLabelEXT = packet.read_nullable_raw_ptr();
    trace!("called vkQueueInsertDebugUtilsLabelEXT({queue:?}, {p_label_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_insert_debug_utils_label_ext)(
            queue,
            p_label_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginDebugUtilsLabelEXT.html>"]
fn vk_cmd_begin_debug_utils_label_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_label_info: *const VkDebugUtilsLabelEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginDebugUtilsLabelEXT({command_buffer:?}, {p_label_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_debug_utils_label_ext)(
            command_buffer,
            p_label_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndDebugUtilsLabelEXT.html>"]
fn vk_cmd_end_debug_utils_label_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdEndDebugUtilsLabelEXT({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_debug_utils_label_ext)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdInsertDebugUtilsLabelEXT.html>"]
fn vk_cmd_insert_debug_utils_label_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_label_info: *const VkDebugUtilsLabelEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdInsertDebugUtilsLabelEXT({command_buffer:?}, {p_label_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_insert_debug_utils_label_ext)(
            command_buffer,
            p_label_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDebugUtilsMessengerEXT.html>"]
fn vk_create_debug_utils_messenger_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkDebugUtilsMessengerCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_messenger: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDebugUtilsMessengerEXT({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_messenger:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_debug_utils_messenger_ext)(
            instance,
            p_create_info,
            p_allocator,
            p_messenger,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_messenger);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDebugUtilsMessengerEXT.html>"]
fn vk_destroy_debug_utils_messenger_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let messenger: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDebugUtilsMessengerEXT({instance:?}, {messenger:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_debug_utils_messenger_ext)(
            instance,
            messenger,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSubmitDebugUtilsMessageEXT.html>"]
fn vk_submit_debug_utils_message_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let message_severity: vk::DebugUtilsMessageSeverityFlagsEXT = packet.read();
    let message_types: NonDisposableHandle = packet.read();
    let p_callback_data: *const VkDebugUtilsMessengerCallbackDataEXT = packet.read_nullable_raw_ptr();
    trace!("called vkSubmitDebugUtilsMessageEXT({instance:?}, {message_severity:?}, {message_types:?}, {p_callback_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_submit_debug_utils_message_ext)(
            instance,
            message_severity,
            message_types,
            p_callback_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryHostPointerPropertiesEXT.html>"]
fn vk_get_memory_host_pointer_properties_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let handle_type: vk::ExternalMemoryHandleTypeFlags = packet.read();
    let p_host_pointer: *const c_void = packet.read_nullable_raw_ptr();
    let p_memory_host_pointer_properties: *mut VkMemoryHostPointerPropertiesEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryHostPointerPropertiesEXT({device:?}, {handle_type:?}, {p_host_pointer:?}, {p_memory_host_pointer_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_host_pointer_properties_ext)(
            device,
            handle_type,
            p_host_pointer,
            p_memory_host_pointer_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_host_pointer_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarkerAMD.html>"]
fn vk_cmd_write_buffer_marker_amd(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_stage: vk::PipelineStageFlags = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let dst_offset: NonDisposableHandle = packet.read();
    let marker: u32 = packet.read();
    trace!("called vkCmdWriteBufferMarkerAMD({command_buffer:?}, {pipeline_stage:?}, {dst_buffer:?}, {dst_offset:?}, {marker:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_buffer_marker_amd)(
            command_buffer,
            pipeline_stage,
            dst_buffer,
            dst_offset,
            marker,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateRenderPass2.html>"]
fn vk_create_render_pass2(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkRenderPassCreateInfo2 = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_render_pass: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateRenderPass2({device:?}, {p_create_info:?}, {p_allocator:?}, {p_render_pass:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_render_pass2)(
            device,
            p_create_info,
            p_allocator,
            p_render_pass,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_render_pass);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRenderPass2.html>"]
fn vk_cmd_begin_render_pass2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_render_pass_begin: *const VkRenderPassBeginInfo = packet.read_nullable_raw_ptr();
    let p_subpass_begin_info: *const VkSubpassBeginInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginRenderPass2({command_buffer:?}, {p_render_pass_begin:?}, {p_subpass_begin_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_render_pass2)(
            command_buffer,
            p_render_pass_begin,
            p_subpass_begin_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdNextSubpass2.html>"]
fn vk_cmd_next_subpass2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_subpass_begin_info: *const VkSubpassBeginInfo = packet.read_nullable_raw_ptr();
    let p_subpass_end_info: *const VkSubpassEndInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdNextSubpass2({command_buffer:?}, {p_subpass_begin_info:?}, {p_subpass_end_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_next_subpass2)(
            command_buffer,
            p_subpass_begin_info,
            p_subpass_end_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRenderPass2.html>"]
fn vk_cmd_end_render_pass2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_subpass_end_info: *const VkSubpassEndInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdEndRenderPass2({command_buffer:?}, {p_subpass_end_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_render_pass2)(
            command_buffer,
            p_subpass_end_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSemaphoreCounterValue.html>"]
fn vk_get_semaphore_counter_value(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let semaphore: NonDisposableHandle = packet.read();
    let p_value: *mut u64 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSemaphoreCounterValue({device:?}, {semaphore:?}, {p_value:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_semaphore_counter_value)(
            device,
            semaphore,
            p_value,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_value);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitSemaphores.html>"]
fn vk_wait_semaphores(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_wait_info: *const VkSemaphoreWaitInfo = packet.read_nullable_raw_ptr();
    let timeout: u64 = packet.read();
    trace!("called vkWaitSemaphores({device:?}, {p_wait_info:?}, {timeout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_wait_semaphores)(
            device,
            p_wait_info,
            timeout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSignalSemaphore.html>"]
fn vk_signal_semaphore(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_signal_info: *const VkSemaphoreSignalInfo = packet.read_nullable_raw_ptr();
    trace!("called vkSignalSemaphore({device:?}, {p_signal_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_signal_semaphore)(
            device,
            p_signal_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAndroidHardwareBufferPropertiesANDROID.html>"]
fn vk_get_android_hardware_buffer_properties_android(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer: *const usize = packet.read_nullable_raw_ptr();
    let p_properties: *mut VkAndroidHardwareBufferPropertiesANDROID = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetAndroidHardwareBufferPropertiesANDROID({device:?}, {buffer:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_android_hardware_buffer_properties_android)(
            device,
            buffer,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMemoryAndroidHardwareBufferANDROID.html>"]
fn vk_get_memory_android_hardware_buffer_android(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkMemoryGetAndroidHardwareBufferInfoANDROID = packet.read_nullable_raw_ptr();
    let p_buffer: *mut *mut usize = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMemoryAndroidHardwareBufferANDROID({device:?}, {p_info:?}, {p_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_memory_android_hardware_buffer_android)(
            device,
            p_info,
            p_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_buffer);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectCount.html>"]
fn vk_cmd_draw_indirect_count(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let count_buffer: NonDisposableHandle = packet.read();
    let count_buffer_offset: NonDisposableHandle = packet.read();
    let max_draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawIndirectCount({command_buffer:?}, {buffer:?}, {offset:?}, {count_buffer:?}, {count_buffer_offset:?}, {max_draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indirect_count)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndexedIndirectCount.html>"]
fn vk_cmd_draw_indexed_indirect_count(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let count_buffer: NonDisposableHandle = packet.read();
    let count_buffer_offset: NonDisposableHandle = packet.read();
    let max_draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawIndexedIndirectCount({command_buffer:?}, {buffer:?}, {offset:?}, {count_buffer:?}, {count_buffer_offset:?}, {max_draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indexed_indirect_count)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCheckpointNV.html>"]
fn vk_cmd_set_checkpoint_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_checkpoint_marker: *const c_void = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetCheckpointNV({command_buffer:?}, {p_checkpoint_marker:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_checkpoint_nv)(
            command_buffer,
            p_checkpoint_marker,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointDataNV.html>"]
fn vk_get_queue_checkpoint_data_nv(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let (mut p_checkpoint_data_count, p_checkpoint_data) = packet.read_and_allocate_vk_array_count::<VkCheckpointDataNV>();
    trace!("called vkGetQueueCheckpointDataNV({queue:?}, {p_checkpoint_data_count:?}, {p_checkpoint_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_queue_checkpoint_data_nv)(
            queue,
            &mut p_checkpoint_data_count,
            p_checkpoint_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_checkpoint_data_count, p_checkpoint_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindTransformFeedbackBuffersEXT.html>"]
fn vk_cmd_bind_transform_feedback_buffers_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_binding: u32 = packet.read();
    let binding_count: u32 = packet.read();
    let p_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_sizes: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindTransformFeedbackBuffersEXT({command_buffer:?}, {first_binding:?}, {binding_count:?}, {p_buffers:?}, {p_offsets:?}, {p_sizes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_transform_feedback_buffers_ext)(
            command_buffer,
            first_binding,
            binding_count,
            p_buffers,
            p_offsets,
            p_sizes,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginTransformFeedbackEXT.html>"]
fn vk_cmd_begin_transform_feedback_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_counter_buffer: u32 = packet.read();
    let counter_buffer_count: u32 = packet.read();
    let p_counter_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_counter_buffer_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginTransformFeedbackEXT({command_buffer:?}, {first_counter_buffer:?}, {counter_buffer_count:?}, {p_counter_buffers:?}, {p_counter_buffer_offsets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_transform_feedback_ext)(
            command_buffer,
            first_counter_buffer,
            counter_buffer_count,
            p_counter_buffers,
            p_counter_buffer_offsets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndTransformFeedbackEXT.html>"]
fn vk_cmd_end_transform_feedback_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_counter_buffer: u32 = packet.read();
    let counter_buffer_count: u32 = packet.read();
    let p_counter_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_counter_buffer_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdEndTransformFeedbackEXT({command_buffer:?}, {first_counter_buffer:?}, {counter_buffer_count:?}, {p_counter_buffers:?}, {p_counter_buffer_offsets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_transform_feedback_ext)(
            command_buffer,
            first_counter_buffer,
            counter_buffer_count,
            p_counter_buffers,
            p_counter_buffer_offsets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginQueryIndexedEXT.html>"]
fn vk_cmd_begin_query_indexed_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    let flags: NonDisposableHandle = packet.read();
    let index: u32 = packet.read();
    trace!("called vkCmdBeginQueryIndexedEXT({command_buffer:?}, {query_pool:?}, {query:?}, {flags:?}, {index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_query_indexed_ext)(
            command_buffer,
            query_pool,
            query,
            flags,
            index,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndQueryIndexedEXT.html>"]
fn vk_cmd_end_query_indexed_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    let index: u32 = packet.read();
    trace!("called vkCmdEndQueryIndexedEXT({command_buffer:?}, {query_pool:?}, {query:?}, {index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_query_indexed_ext)(
            command_buffer,
            query_pool,
            query,
            index,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawIndirectByteCountEXT.html>"]
fn vk_cmd_draw_indirect_byte_count_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let instance_count: u32 = packet.read();
    let first_instance: u32 = packet.read();
    let counter_buffer: NonDisposableHandle = packet.read();
    let counter_buffer_offset: NonDisposableHandle = packet.read();
    let counter_offset: u32 = packet.read();
    let vertex_stride: u32 = packet.read();
    trace!("called vkCmdDrawIndirectByteCountEXT({command_buffer:?}, {instance_count:?}, {first_instance:?}, {counter_buffer:?}, {counter_buffer_offset:?}, {counter_offset:?}, {vertex_stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_indirect_byte_count_ext)(
            command_buffer,
            instance_count,
            first_instance,
            counter_buffer,
            counter_buffer_offset,
            counter_offset,
            vertex_stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorNV.html>"]
fn vk_cmd_set_exclusive_scissor_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_exclusive_scissor: u32 = packet.read();
    let exclusive_scissor_count: u32 = packet.read();
    let p_exclusive_scissors: *const VkRect2D = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetExclusiveScissorNV({command_buffer:?}, {first_exclusive_scissor:?}, {exclusive_scissor_count:?}, {p_exclusive_scissors:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_exclusive_scissor_nv)(
            command_buffer,
            first_exclusive_scissor,
            exclusive_scissor_count,
            p_exclusive_scissors,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetExclusiveScissorEnableNV.html>"]
fn vk_cmd_set_exclusive_scissor_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_exclusive_scissor: u32 = packet.read();
    let exclusive_scissor_count: u32 = packet.read();
    let p_exclusive_scissor_enables: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetExclusiveScissorEnableNV({command_buffer:?}, {first_exclusive_scissor:?}, {exclusive_scissor_count:?}, {p_exclusive_scissor_enables:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_exclusive_scissor_enable_nv)(
            command_buffer,
            first_exclusive_scissor,
            exclusive_scissor_count,
            p_exclusive_scissor_enables,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadingRateImageNV.html>"]
fn vk_cmd_bind_shading_rate_image_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let image_view: NonDisposableHandle = packet.read();
    let image_layout: NonDisposableHandle = packet.read();
    trace!("called vkCmdBindShadingRateImageNV({command_buffer:?}, {image_view:?}, {image_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_shading_rate_image_nv)(
            command_buffer,
            image_view,
            image_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportShadingRatePaletteNV.html>"]
fn vk_cmd_set_viewport_shading_rate_palette_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_viewport: u32 = packet.read();
    let viewport_count: u32 = packet.read();
    let p_shading_rate_palettes: *const VkShadingRatePaletteNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetViewportShadingRatePaletteNV({command_buffer:?}, {first_viewport:?}, {viewport_count:?}, {p_shading_rate_palettes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport_shading_rate_palette_nv)(
            command_buffer,
            first_viewport,
            viewport_count,
            p_shading_rate_palettes,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoarseSampleOrderNV.html>"]
fn vk_cmd_set_coarse_sample_order_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let sample_order_type: NonDisposableHandle = packet.read();
    let custom_sample_order_count: u32 = packet.read();
    let p_custom_sample_orders: *const VkCoarseSampleOrderCustomNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetCoarseSampleOrderNV({command_buffer:?}, {sample_order_type:?}, {custom_sample_order_count:?}, {p_custom_sample_orders:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coarse_sample_order_nv)(
            command_buffer,
            sample_order_type,
            custom_sample_order_count,
            p_custom_sample_orders,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksNV.html>"]
fn vk_cmd_draw_mesh_tasks_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let task_count: u32 = packet.read();
    let first_task: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksNV({command_buffer:?}, {task_count:?}, {first_task:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_nv)(
            command_buffer,
            task_count,
            first_task,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectNV.html>"]
fn vk_cmd_draw_mesh_tasks_indirect_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksIndirectNV({command_buffer:?}, {buffer:?}, {offset:?}, {draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_indirect_nv)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountNV.html>"]
fn vk_cmd_draw_mesh_tasks_indirect_count_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let count_buffer: NonDisposableHandle = packet.read();
    let count_buffer_offset: NonDisposableHandle = packet.read();
    let max_draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksIndirectCountNV({command_buffer:?}, {buffer:?}, {offset:?}, {count_buffer:?}, {count_buffer_offset:?}, {max_draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_indirect_count_nv)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksEXT.html>"]
fn vk_cmd_draw_mesh_tasks_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let group_count_x: u32 = packet.read();
    let group_count_y: u32 = packet.read();
    let group_count_z: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksEXT({command_buffer:?}, {group_count_x:?}, {group_count_y:?}, {group_count_z:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_ext)(
            command_buffer,
            group_count_x,
            group_count_y,
            group_count_z,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectEXT.html>"]
fn vk_cmd_draw_mesh_tasks_indirect_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksIndirectEXT({command_buffer:?}, {buffer:?}, {offset:?}, {draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_indirect_ext)(
            command_buffer,
            buffer,
            offset,
            draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDrawMeshTasksIndirectCountEXT.html>"]
fn vk_cmd_draw_mesh_tasks_indirect_count_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let count_buffer: NonDisposableHandle = packet.read();
    let count_buffer_offset: NonDisposableHandle = packet.read();
    let max_draw_count: u32 = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDrawMeshTasksIndirectCountEXT({command_buffer:?}, {buffer:?}, {offset:?}, {count_buffer:?}, {count_buffer_offset:?}, {max_draw_count:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_draw_mesh_tasks_indirect_count_ext)(
            command_buffer,
            buffer,
            offset,
            count_buffer,
            count_buffer_offset,
            max_draw_count,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCompileDeferredNV.html>"]
fn vk_compile_deferred_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let shader: u32 = packet.read();
    trace!("called vkCompileDeferredNV({device:?}, {pipeline:?}, {shader:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_compile_deferred_nv)(
            device,
            pipeline,
            shader,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureNV.html>"]
fn vk_create_acceleration_structure_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkAccelerationStructureCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_acceleration_structure: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateAccelerationStructureNV({device:?}, {p_create_info:?}, {p_allocator:?}, {p_acceleration_structure:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_acceleration_structure_nv)(
            device,
            p_create_info,
            p_allocator,
            p_acceleration_structure,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_acceleration_structure);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindInvocationMaskHUAWEI.html>"]
fn vk_cmd_bind_invocation_mask_huawei(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let image_view: NonDisposableHandle = packet.read();
    let image_layout: NonDisposableHandle = packet.read();
    trace!("called vkCmdBindInvocationMaskHUAWEI({command_buffer:?}, {image_view:?}, {image_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_invocation_mask_huawei)(
            command_buffer,
            image_view,
            image_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureKHR.html>"]
fn vk_destroy_acceleration_structure_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let acceleration_structure: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyAccelerationStructureKHR({device:?}, {acceleration_structure:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_acceleration_structure_khr)(
            device,
            acceleration_structure,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyAccelerationStructureNV.html>"]
fn vk_destroy_acceleration_structure_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let acceleration_structure: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyAccelerationStructureNV({device:?}, {acceleration_structure:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_acceleration_structure_nv)(
            device,
            acceleration_structure,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureMemoryRequirementsNV.html>"]
fn vk_get_acceleration_structure_memory_requirements_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkAccelerationStructureMemoryRequirementsInfoNV = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetAccelerationStructureMemoryRequirementsNV({device:?}, {p_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_acceleration_structure_memory_requirements_nv)(
            device,
            p_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindAccelerationStructureMemoryNV.html>"]
fn vk_bind_acceleration_structure_memory_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let bind_info_count: u32 = packet.read();
    let p_bind_infos: *const VkBindAccelerationStructureMemoryInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkBindAccelerationStructureMemoryNV({device:?}, {bind_info_count:?}, {p_bind_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_acceleration_structure_memory_nv)(
            device,
            bind_info_count,
            p_bind_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureNV.html>"]
fn vk_cmd_copy_acceleration_structure_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let dst: NonDisposableHandle = packet.read();
    let src: NonDisposableHandle = packet.read();
    let mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdCopyAccelerationStructureNV({command_buffer:?}, {dst:?}, {src:?}, {mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_acceleration_structure_nv)(
            command_buffer,
            dst,
            src,
            mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureKHR.html>"]
fn vk_cmd_copy_acceleration_structure_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyAccelerationStructureInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyAccelerationStructureKHR({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_acceleration_structure_khr)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureKHR.html>"]
fn vk_copy_acceleration_structure_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyAccelerationStructureInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCopyAccelerationStructureKHR({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_acceleration_structure_khr)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyAccelerationStructureToMemoryKHR.html>"]
fn vk_cmd_copy_acceleration_structure_to_memory_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyAccelerationStructureToMemoryInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyAccelerationStructureToMemoryKHR({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_acceleration_structure_to_memory_khr)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyAccelerationStructureToMemoryKHR.html>"]
fn vk_copy_acceleration_structure_to_memory_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyAccelerationStructureToMemoryInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCopyAccelerationStructureToMemoryKHR({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_acceleration_structure_to_memory_khr)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToAccelerationStructureKHR.html>"]
fn vk_cmd_copy_memory_to_acceleration_structure_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMemoryToAccelerationStructureInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyMemoryToAccelerationStructureKHR({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_memory_to_acceleration_structure_khr)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToAccelerationStructureKHR.html>"]
fn vk_copy_memory_to_acceleration_structure_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMemoryToAccelerationStructureInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCopyMemoryToAccelerationStructureKHR({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_memory_to_acceleration_structure_khr)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesKHR.html>"]
fn vk_cmd_write_acceleration_structures_properties_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let acceleration_structure_count: u32 = packet.read();
    let p_acceleration_structures: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let query_type: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    trace!("called vkCmdWriteAccelerationStructuresPropertiesKHR({command_buffer:?}, {acceleration_structure_count:?}, {p_acceleration_structures:?}, {query_type:?}, {query_pool:?}, {first_query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_acceleration_structures_properties_khr)(
            command_buffer,
            acceleration_structure_count,
            p_acceleration_structures,
            query_type,
            query_pool,
            first_query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteAccelerationStructuresPropertiesNV.html>"]
fn vk_cmd_write_acceleration_structures_properties_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let acceleration_structure_count: u32 = packet.read();
    let p_acceleration_structures: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let query_type: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    trace!("called vkCmdWriteAccelerationStructuresPropertiesNV({command_buffer:?}, {acceleration_structure_count:?}, {p_acceleration_structures:?}, {query_type:?}, {query_pool:?}, {first_query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_acceleration_structures_properties_nv)(
            command_buffer,
            acceleration_structure_count,
            p_acceleration_structures,
            query_type,
            query_pool,
            first_query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructureNV.html>"]
fn vk_cmd_build_acceleration_structure_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkAccelerationStructureInfoNV = packet.read_nullable_raw_ptr();
    let instance_data: NonDisposableHandle = packet.read();
    let instance_offset: NonDisposableHandle = packet.read();
    let update: NonDisposableHandle = packet.read();
    let dst: NonDisposableHandle = packet.read();
    let src: NonDisposableHandle = packet.read();
    let scratch: NonDisposableHandle = packet.read();
    let scratch_offset: NonDisposableHandle = packet.read();
    trace!("called vkCmdBuildAccelerationStructureNV({command_buffer:?}, {p_info:?}, {instance_data:?}, {instance_offset:?}, {update:?}, {dst:?}, {src:?}, {scratch:?}, {scratch_offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_build_acceleration_structure_nv)(
            command_buffer,
            p_info,
            instance_data,
            instance_offset,
            update,
            dst,
            src,
            scratch,
            scratch_offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWriteAccelerationStructuresPropertiesKHR.html>"]
fn vk_write_acceleration_structures_properties_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let acceleration_structure_count: u32 = packet.read();
    let p_acceleration_structures: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let query_type: NonDisposableHandle = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    let stride: usize = packet.read();
    trace!("called vkWriteAccelerationStructuresPropertiesKHR({device:?}, {acceleration_structure_count:?}, {p_acceleration_structures:?}, {query_type:?}, {data_size:?}, {p_data:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_write_acceleration_structures_properties_khr)(
            device,
            acceleration_structure_count,
            p_acceleration_structures,
            query_type,
            data_size,
            p_data,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysKHR.html>"]
fn vk_cmd_trace_rays_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_raygen_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_miss_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_hit_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_callable_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let width: u32 = packet.read();
    let height: u32 = packet.read();
    let depth: u32 = packet.read();
    trace!("called vkCmdTraceRaysKHR({command_buffer:?}, {p_raygen_shader_binding_table:?}, {p_miss_shader_binding_table:?}, {p_hit_shader_binding_table:?}, {p_callable_shader_binding_table:?}, {width:?}, {height:?}, {depth:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_trace_rays_khr)(
            command_buffer,
            p_raygen_shader_binding_table,
            p_miss_shader_binding_table,
            p_hit_shader_binding_table,
            p_callable_shader_binding_table,
            width,
            height,
            depth,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysNV.html>"]
fn vk_cmd_trace_rays_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let raygen_shader_binding_table_buffer: NonDisposableHandle = packet.read();
    let raygen_shader_binding_offset: NonDisposableHandle = packet.read();
    let miss_shader_binding_table_buffer: NonDisposableHandle = packet.read();
    let miss_shader_binding_offset: NonDisposableHandle = packet.read();
    let miss_shader_binding_stride: NonDisposableHandle = packet.read();
    let hit_shader_binding_table_buffer: NonDisposableHandle = packet.read();
    let hit_shader_binding_offset: NonDisposableHandle = packet.read();
    let hit_shader_binding_stride: NonDisposableHandle = packet.read();
    let callable_shader_binding_table_buffer: NonDisposableHandle = packet.read();
    let callable_shader_binding_offset: NonDisposableHandle = packet.read();
    let callable_shader_binding_stride: NonDisposableHandle = packet.read();
    let width: u32 = packet.read();
    let height: u32 = packet.read();
    let depth: u32 = packet.read();
    trace!("called vkCmdTraceRaysNV({command_buffer:?}, {raygen_shader_binding_table_buffer:?}, {raygen_shader_binding_offset:?}, {miss_shader_binding_table_buffer:?}, {miss_shader_binding_offset:?}, {miss_shader_binding_stride:?}, {hit_shader_binding_table_buffer:?}, {hit_shader_binding_offset:?}, {hit_shader_binding_stride:?}, {callable_shader_binding_table_buffer:?}, {callable_shader_binding_offset:?}, {callable_shader_binding_stride:?}, {width:?}, {height:?}, {depth:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_trace_rays_nv)(
            command_buffer,
            raygen_shader_binding_table_buffer,
            raygen_shader_binding_offset,
            miss_shader_binding_table_buffer,
            miss_shader_binding_offset,
            miss_shader_binding_stride,
            hit_shader_binding_table_buffer,
            hit_shader_binding_offset,
            hit_shader_binding_stride,
            callable_shader_binding_table_buffer,
            callable_shader_binding_offset,
            callable_shader_binding_stride,
            width,
            height,
            depth,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupHandlesKHR.html>"]
fn vk_get_ray_tracing_shader_group_handles_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let first_group: u32 = packet.read();
    let group_count: u32 = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRayTracingShaderGroupHandlesKHR({device:?}, {pipeline:?}, {first_group:?}, {group_count:?}, {data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_ray_tracing_shader_group_handles_khr)(
            device,
            pipeline,
            first_group,
            group_count,
            data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingCaptureReplayShaderGroupHandlesKHR.html>"]
fn vk_get_ray_tracing_capture_replay_shader_group_handles_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let first_group: u32 = packet.read();
    let group_count: u32 = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetRayTracingCaptureReplayShaderGroupHandlesKHR({device:?}, {pipeline:?}, {first_group:?}, {group_count:?}, {data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_ray_tracing_capture_replay_shader_group_handles_khr)(
            device,
            pipeline,
            first_group,
            group_count,
            data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureHandleNV.html>"]
fn vk_get_acceleration_structure_handle_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let acceleration_structure: NonDisposableHandle = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetAccelerationStructureHandleNV({device:?}, {acceleration_structure:?}, {data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_acceleration_structure_handle_nv)(
            device,
            acceleration_structure,
            data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesNV.html>"]
fn vk_create_ray_tracing_pipelines_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkRayTracingPipelineCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipelines: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateRayTracingPipelinesNV({device:?}, {pipeline_cache:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_pipelines:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_ray_tracing_pipelines_nv)(
            device,
            pipeline_cache,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_pipelines,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipelines);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateRayTracingPipelinesKHR.html>"]
fn vk_create_ray_tracing_pipelines_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkRayTracingPipelineCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipelines: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateRayTracingPipelinesKHR({device:?}, {deferred_operation:?}, {pipeline_cache:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_pipelines:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_ray_tracing_pipelines_khr)(
            device,
            deferred_operation,
            pipeline_cache,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_pipelines,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipelines);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.html>"]
fn vk_get_physical_device_cooperative_matrix_properties_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkCooperativeMatrixPropertiesNV>();
    trace!("called vkGetPhysicalDeviceCooperativeMatrixPropertiesNV({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_cooperative_matrix_properties_nv)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirectKHR.html>"]
fn vk_cmd_trace_rays_indirect_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_raygen_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_miss_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_hit_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let p_callable_shader_binding_table: *const VkStridedDeviceAddressRegionKHR = packet.read_nullable_raw_ptr();
    let indirect_device_address: NonDisposableHandle = packet.read();
    trace!("called vkCmdTraceRaysIndirectKHR({command_buffer:?}, {p_raygen_shader_binding_table:?}, {p_miss_shader_binding_table:?}, {p_hit_shader_binding_table:?}, {p_callable_shader_binding_table:?}, {indirect_device_address:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_trace_rays_indirect_khr)(
            command_buffer,
            p_raygen_shader_binding_table,
            p_miss_shader_binding_table,
            p_hit_shader_binding_table,
            p_callable_shader_binding_table,
            indirect_device_address,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdTraceRaysIndirect2KHR.html>"]
fn vk_cmd_trace_rays_indirect2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let indirect_device_address: NonDisposableHandle = packet.read();
    trace!("called vkCmdTraceRaysIndirect2KHR({command_buffer:?}, {indirect_device_address:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_trace_rays_indirect2_khr)(
            command_buffer,
            indirect_device_address,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceAccelerationStructureCompatibilityKHR.html>"]
fn vk_get_device_acceleration_structure_compatibility_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_version_info: *const VkAccelerationStructureVersionInfoKHR = packet.read_nullable_raw_ptr();
    let p_compatibility: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceAccelerationStructureCompatibilityKHR({device:?}, {p_version_info:?}, {p_compatibility:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_acceleration_structure_compatibility_khr)(
            device,
            p_version_info,
            p_compatibility,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_compatibility);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetRayTracingShaderGroupStackSizeKHR.html>"]
fn vk_get_ray_tracing_shader_group_stack_size_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline: NonDisposableHandle = packet.read();
    let group: u32 = packet.read();
    let group_shader: NonDisposableHandle = packet.read();
    trace!("called vkGetRayTracingShaderGroupStackSizeKHR({device:?}, {pipeline:?}, {group:?}, {group_shader:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_ray_tracing_shader_group_stack_size_khr)(
            device,
            pipeline,
            group,
            group_shader,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRayTracingPipelineStackSizeKHR.html>"]
fn vk_cmd_set_ray_tracing_pipeline_stack_size_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_stack_size: u32 = packet.read();
    trace!("called vkCmdSetRayTracingPipelineStackSizeKHR({command_buffer:?}, {pipeline_stack_size:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_ray_tracing_pipeline_stack_size_khr)(
            command_buffer,
            pipeline_stack_size,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageViewHandleNVX.html>"]
fn vk_get_image_view_handle_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkImageViewHandleInfoNVX = packet.read_nullable_raw_ptr();
    trace!("called vkGetImageViewHandleNVX({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_view_handle_nvx)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageViewAddressNVX.html>"]
fn vk_get_image_view_address_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image_view: NonDisposableHandle = packet.read();
    let p_properties: *mut VkImageViewAddressPropertiesNVX = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageViewAddressNVX({device:?}, {image_view:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_view_address_nvx)(
            device,
            image_view,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModes2EXT.html>"]
fn vk_get_physical_device_surface_present_modes2_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_surface_info: *const VkPhysicalDeviceSurfaceInfo2KHR = packet.read_nullable_raw_ptr();
    let (mut p_present_mode_count, p_present_modes) = packet.read_and_allocate_vk_array_count::<NonDisposableHandle>();
    trace!("called vkGetPhysicalDeviceSurfacePresentModes2EXT({physical_device:?}, {p_surface_info:?}, {p_present_mode_count:?}, {p_present_modes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_surface_present_modes2_ext)(
            physical_device,
            p_surface_info,
            &mut p_present_mode_count,
            p_present_modes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_present_mode_count, p_present_modes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceGroupSurfacePresentModes2EXT.html>"]
fn vk_get_device_group_surface_present_modes2_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_surface_info: *const VkPhysicalDeviceSurfaceInfo2KHR = packet.read_nullable_raw_ptr();
    let p_modes: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceGroupSurfacePresentModes2EXT({device:?}, {p_surface_info:?}, {p_modes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_group_surface_present_modes2_ext)(
            device,
            p_surface_info,
            p_modes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_modes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireFullScreenExclusiveModeEXT.html>"]
fn vk_acquire_full_screen_exclusive_mode_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    trace!("called vkAcquireFullScreenExclusiveModeEXT({device:?}, {swapchain:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_full_screen_exclusive_mode_ext)(
            device,
            swapchain,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkReleaseFullScreenExclusiveModeEXT.html>"]
fn vk_release_full_screen_exclusive_mode_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    trace!("called vkReleaseFullScreenExclusiveModeEXT({device:?}, {swapchain:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_release_full_screen_exclusive_mode_ext)(
            device,
            swapchain,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.html>"]
fn vk_enumerate_physical_device_queue_family_performance_query_counters_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let queue_family_index: u32 = packet.read();
    let (mut p_counter_count, p_counters) = packet.read_and_allocate_vk_array_count::<VkPerformanceCounterKHR>();
    let p_counter_descriptions: *mut VkPerformanceCounterDescriptionKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR({physical_device:?}, {queue_family_index:?}, {p_counter_count:?}, {p_counters:?}, {p_counter_descriptions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_enumerate_physical_device_queue_family_performance_query_counters_khr)(
            physical_device,
            queue_family_index,
            &mut p_counter_count,
            p_counters,
            p_counter_descriptions,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_counter_count, p_counters);
    response.write_raw_ptr(p_counter_descriptions);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.html>"]
fn vk_get_physical_device_queue_family_performance_query_passes_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_performance_query_create_info: *const VkQueryPoolPerformanceCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_num_passes: *mut u32 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR({physical_device:?}, {p_performance_query_create_info:?}, {p_num_passes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_queue_family_performance_query_passes_khr)(
            physical_device,
            p_performance_query_create_info,
            p_num_passes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_num_passes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireProfilingLockKHR.html>"]
fn vk_acquire_profiling_lock_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkAcquireProfilingLockInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkAcquireProfilingLockKHR({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_profiling_lock_khr)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkReleaseProfilingLockKHR.html>"]
fn vk_release_profiling_lock_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    trace!("called vkReleaseProfilingLockKHR({device:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_release_profiling_lock_khr)(
            device,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageDrmFormatModifierPropertiesEXT.html>"]
fn vk_get_image_drm_format_modifier_properties_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let p_properties: *mut VkImageDrmFormatModifierPropertiesEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageDrmFormatModifierPropertiesEXT({device:?}, {image:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_drm_format_modifier_properties_ext)(
            device,
            image,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureAddress.html>"]
fn vk_get_buffer_opaque_capture_address(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkBufferDeviceAddressInfo = packet.read_nullable_raw_ptr();
    trace!("called vkGetBufferOpaqueCaptureAddress({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_opaque_capture_address)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferDeviceAddress.html>"]
fn vk_get_buffer_device_address(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkBufferDeviceAddressInfo = packet.read_nullable_raw_ptr();
    trace!("called vkGetBufferDeviceAddress({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_device_address)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateHeadlessSurfaceEXT.html>"]
fn vk_create_headless_surface_ext(mut packet: Packet) {
    let instance: NonDisposableHandle = packet.read();
    let p_create_info: *const VkHeadlessSurfaceCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_surface: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateHeadlessSurfaceEXT({instance:?}, {p_create_info:?}, {p_allocator:?}, {p_surface:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_headless_surface_ext)(
            instance,
            p_create_info,
            p_allocator,
            p_surface,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_surface);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.html>"]
fn vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_combination_count, p_combinations) = packet.read_and_allocate_vk_array_count::<VkFramebufferMixedSamplesCombinationNV>();
    trace!("called vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV({physical_device:?}, {p_combination_count:?}, {p_combinations:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_supported_framebuffer_mixed_samples_combinations_nv)(
            physical_device,
            &mut p_combination_count,
            p_combinations,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_combination_count, p_combinations);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkInitializePerformanceApiINTEL.html>"]
fn vk_initialize_performance_api_intel(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_initialize_info: *const VkInitializePerformanceApiInfoINTEL = packet.read_nullable_raw_ptr();
    trace!("called vkInitializePerformanceApiINTEL({device:?}, {p_initialize_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_initialize_performance_api_intel)(
            device,
            p_initialize_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUninitializePerformanceApiINTEL.html>"]
fn vk_uninitialize_performance_api_intel(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    trace!("called vkUninitializePerformanceApiINTEL({device:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_uninitialize_performance_api_intel)(
            device,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceMarkerINTEL.html>"]
fn vk_cmd_set_performance_marker_intel(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_marker_info: *const VkPerformanceMarkerInfoINTEL = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetPerformanceMarkerINTEL({command_buffer:?}, {p_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_performance_marker_intel)(
            command_buffer,
            p_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceStreamMarkerINTEL.html>"]
fn vk_cmd_set_performance_stream_marker_intel(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_marker_info: *const VkPerformanceStreamMarkerInfoINTEL = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetPerformanceStreamMarkerINTEL({command_buffer:?}, {p_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_performance_stream_marker_intel)(
            command_buffer,
            p_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPerformanceOverrideINTEL.html>"]
fn vk_cmd_set_performance_override_intel(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_override_info: *const VkPerformanceOverrideInfoINTEL = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetPerformanceOverrideINTEL({command_buffer:?}, {p_override_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_performance_override_intel)(
            command_buffer,
            p_override_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquirePerformanceConfigurationINTEL.html>"]
fn vk_acquire_performance_configuration_intel(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_acquire_info: *const VkPerformanceConfigurationAcquireInfoINTEL = packet.read_nullable_raw_ptr();
    let p_configuration: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkAcquirePerformanceConfigurationINTEL({device:?}, {p_acquire_info:?}, {p_configuration:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_performance_configuration_intel)(
            device,
            p_acquire_info,
            p_configuration,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_configuration);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkReleasePerformanceConfigurationINTEL.html>"]
fn vk_release_performance_configuration_intel(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let configuration: NonDisposableHandle = packet.read();
    trace!("called vkReleasePerformanceConfigurationINTEL({device:?}, {configuration:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_release_performance_configuration_intel)(
            device,
            configuration,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSetPerformanceConfigurationINTEL.html>"]
fn vk_queue_set_performance_configuration_intel(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let configuration: NonDisposableHandle = packet.read();
    trace!("called vkQueueSetPerformanceConfigurationINTEL({queue:?}, {configuration:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_set_performance_configuration_intel)(
            queue,
            configuration,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPerformanceParameterINTEL.html>"]
fn vk_get_performance_parameter_intel(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let parameter: NonDisposableHandle = packet.read();
    let p_value: *mut VkPerformanceValueINTEL = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPerformanceParameterINTEL({device:?}, {parameter:?}, {p_value:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_performance_parameter_intel)(
            device,
            parameter,
            p_value,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_value);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMemoryOpaqueCaptureAddress.html>"]
fn vk_get_device_memory_opaque_capture_address(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkDeviceMemoryOpaqueCaptureAddressInfo = packet.read_nullable_raw_ptr();
    trace!("called vkGetDeviceMemoryOpaqueCaptureAddress({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_memory_opaque_capture_address)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutablePropertiesKHR.html>"]
fn vk_get_pipeline_executable_properties_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_pipeline_info: *const VkPipelineInfoKHR = packet.read_nullable_raw_ptr();
    let (mut p_executable_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkPipelineExecutablePropertiesKHR>();
    trace!("called vkGetPipelineExecutablePropertiesKHR({device:?}, {p_pipeline_info:?}, {p_executable_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_executable_properties_khr)(
            device,
            p_pipeline_info,
            &mut p_executable_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_executable_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableStatisticsKHR.html>"]
fn vk_get_pipeline_executable_statistics_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_executable_info: *const VkPipelineExecutableInfoKHR = packet.read_nullable_raw_ptr();
    let (mut p_statistic_count, p_statistics) = packet.read_and_allocate_vk_array_count::<VkPipelineExecutableStatisticKHR>();
    trace!("called vkGetPipelineExecutableStatisticsKHR({device:?}, {p_executable_info:?}, {p_statistic_count:?}, {p_statistics:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_executable_statistics_khr)(
            device,
            p_executable_info,
            &mut p_statistic_count,
            p_statistics,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_statistic_count, p_statistics);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineExecutableInternalRepresentationsKHR.html>"]
fn vk_get_pipeline_executable_internal_representations_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_executable_info: *const VkPipelineExecutableInfoKHR = packet.read_nullable_raw_ptr();
    let (mut p_internal_representation_count, p_internal_representations) = packet.read_and_allocate_vk_array_count::<VkPipelineExecutableInternalRepresentationKHR>();
    trace!("called vkGetPipelineExecutableInternalRepresentationsKHR({device:?}, {p_executable_info:?}, {p_internal_representation_count:?}, {p_internal_representations:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_executable_internal_representations_khr)(
            device,
            p_executable_info,
            &mut p_internal_representation_count,
            p_internal_representations,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_internal_representation_count, p_internal_representations);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleKHR.html>"]
fn vk_cmd_set_line_stipple_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let line_stipple_factor: u32 = packet.read();
    let line_stipple_pattern: u16 = packet.read();
    trace!("called vkCmdSetLineStippleKHR({command_buffer:?}, {line_stipple_factor:?}, {line_stipple_pattern:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_line_stipple_khr)(
            command_buffer,
            line_stipple_factor,
            line_stipple_pattern,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceToolProperties.html>"]
fn vk_get_physical_device_tool_properties(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_tool_count, p_tool_properties) = packet.read_and_allocate_vk_array_count::<VkPhysicalDeviceToolProperties>();
    trace!("called vkGetPhysicalDeviceToolProperties({physical_device:?}, {p_tool_count:?}, {p_tool_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_tool_properties)(
            physical_device,
            &mut p_tool_count,
            p_tool_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_tool_count, p_tool_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateAccelerationStructureKHR.html>"]
fn vk_create_acceleration_structure_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkAccelerationStructureCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_acceleration_structure: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateAccelerationStructureKHR({device:?}, {p_create_info:?}, {p_allocator:?}, {p_acceleration_structure:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_acceleration_structure_khr)(
            device,
            p_create_info,
            p_allocator,
            p_acceleration_structure,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_acceleration_structure);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresKHR.html>"]
fn vk_cmd_build_acceleration_structures_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let info_count: u32 = packet.read();
    let p_infos: *const VkAccelerationStructureBuildGeometryInfoKHR = packet.read_nullable_raw_ptr();
    let pp_build_range_infos: *const *const VkAccelerationStructureBuildRangeInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBuildAccelerationStructuresKHR({command_buffer:?}, {info_count:?}, {p_infos:?}, {pp_build_range_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_build_acceleration_structures_khr)(
            command_buffer,
            info_count,
            p_infos,
            pp_build_range_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBuildAccelerationStructuresIndirectKHR.html>"]
fn vk_cmd_build_acceleration_structures_indirect_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let info_count: u32 = packet.read();
    let p_infos: *const VkAccelerationStructureBuildGeometryInfoKHR = packet.read_nullable_raw_ptr();
    let p_indirect_device_addresses: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_indirect_strides: *const u32 = packet.read_nullable_raw_ptr();
    let pp_max_primitive_counts: *const *const u32 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBuildAccelerationStructuresIndirectKHR({command_buffer:?}, {info_count:?}, {p_infos:?}, {p_indirect_device_addresses:?}, {p_indirect_strides:?}, {pp_max_primitive_counts:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_build_acceleration_structures_indirect_khr)(
            command_buffer,
            info_count,
            p_infos,
            p_indirect_device_addresses,
            p_indirect_strides,
            pp_max_primitive_counts,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBuildAccelerationStructuresKHR.html>"]
fn vk_build_acceleration_structures_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let info_count: u32 = packet.read();
    let p_infos: *const VkAccelerationStructureBuildGeometryInfoKHR = packet.read_nullable_raw_ptr();
    let pp_build_range_infos: *const *const VkAccelerationStructureBuildRangeInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkBuildAccelerationStructuresKHR({device:?}, {deferred_operation:?}, {info_count:?}, {p_infos:?}, {pp_build_range_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_build_acceleration_structures_khr)(
            device,
            deferred_operation,
            info_count,
            p_infos,
            pp_build_range_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureDeviceAddressKHR.html>"]
fn vk_get_acceleration_structure_device_address_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkAccelerationStructureDeviceAddressInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkGetAccelerationStructureDeviceAddressKHR({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_acceleration_structure_device_address_khr)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateDeferredOperationKHR.html>"]
fn vk_create_deferred_operation_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_deferred_operation: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateDeferredOperationKHR({device:?}, {p_allocator:?}, {p_deferred_operation:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_deferred_operation_khr)(
            device,
            p_allocator,
            p_deferred_operation,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_deferred_operation);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyDeferredOperationKHR.html>"]
fn vk_destroy_deferred_operation_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let operation: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyDeferredOperationKHR({device:?}, {operation:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_deferred_operation_khr)(
            device,
            operation,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationMaxConcurrencyKHR.html>"]
fn vk_get_deferred_operation_max_concurrency_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let operation: NonDisposableHandle = packet.read();
    trace!("called vkGetDeferredOperationMaxConcurrencyKHR({device:?}, {operation:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_deferred_operation_max_concurrency_khr)(
            device,
            operation,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeferredOperationResultKHR.html>"]
fn vk_get_deferred_operation_result_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let operation: NonDisposableHandle = packet.read();
    trace!("called vkGetDeferredOperationResultKHR({device:?}, {operation:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_deferred_operation_result_khr)(
            device,
            operation,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDeferredOperationJoinKHR.html>"]
fn vk_deferred_operation_join_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let operation: NonDisposableHandle = packet.read();
    trace!("called vkDeferredOperationJoinKHR({device:?}, {operation:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_deferred_operation_join_khr)(
            device,
            operation,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectMemoryRequirementsNV.html>"]
fn vk_get_pipeline_indirect_memory_requirements_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkComputePipelineCreateInfo = packet.read_nullable_raw_ptr();
    let p_memory_requirements: *mut VkMemoryRequirements2 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPipelineIndirectMemoryRequirementsNV({device:?}, {p_create_info:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_indirect_memory_requirements_nv)(
            device,
            p_create_info,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelineIndirectDeviceAddressNV.html>"]
fn vk_get_pipeline_indirect_device_address_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkPipelineIndirectDeviceAddressInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkGetPipelineIndirectDeviceAddressNV({device:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_indirect_device_address_nv)(
            device,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCullMode.html>"]
fn vk_cmd_set_cull_mode(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let cull_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetCullMode({command_buffer:?}, {cull_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_cull_mode)(
            command_buffer,
            cull_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetFrontFace.html>"]
fn vk_cmd_set_front_face(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let front_face: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetFrontFace({command_buffer:?}, {front_face:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_front_face)(
            command_buffer,
            front_face,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveTopology.html>"]
fn vk_cmd_set_primitive_topology(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let primitive_topology: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetPrimitiveTopology({command_buffer:?}, {primitive_topology:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_primitive_topology)(
            command_buffer,
            primitive_topology,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWithCount.html>"]
fn vk_cmd_set_viewport_with_count(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let viewport_count: u32 = packet.read();
    let p_viewports: *const VkViewport = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetViewportWithCount({command_buffer:?}, {viewport_count:?}, {p_viewports:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport_with_count)(
            command_buffer,
            viewport_count,
            p_viewports,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetScissorWithCount.html>"]
fn vk_cmd_set_scissor_with_count(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let scissor_count: u32 = packet.read();
    let p_scissors: *const VkRect2D = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetScissorWithCount({command_buffer:?}, {scissor_count:?}, {p_scissors:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_scissor_with_count)(
            command_buffer,
            scissor_count,
            p_scissors,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindIndexBuffer2KHR.html>"]
fn vk_cmd_bind_index_buffer2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer: NonDisposableHandle = packet.read();
    let offset: NonDisposableHandle = packet.read();
    let size: NonDisposableHandle = packet.read();
    let index_type: NonDisposableHandle = packet.read();
    trace!("called vkCmdBindIndexBuffer2KHR({command_buffer:?}, {buffer:?}, {offset:?}, {size:?}, {index_type:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_index_buffer2_khr)(
            command_buffer,
            buffer,
            offset,
            size,
            index_type,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindVertexBuffers2.html>"]
fn vk_cmd_bind_vertex_buffers2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_binding: u32 = packet.read();
    let binding_count: u32 = packet.read();
    let p_buffers: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_sizes: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_strides: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindVertexBuffers2({command_buffer:?}, {first_binding:?}, {binding_count:?}, {p_buffers:?}, {p_offsets:?}, {p_sizes:?}, {p_strides:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_vertex_buffers2)(
            command_buffer,
            first_binding,
            binding_count,
            p_buffers,
            p_offsets,
            p_sizes,
            p_strides,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthTestEnable.html>"]
fn vk_cmd_set_depth_test_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_test_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthTestEnable({command_buffer:?}, {depth_test_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_test_enable)(
            command_buffer,
            depth_test_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthWriteEnable.html>"]
fn vk_cmd_set_depth_write_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_write_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthWriteEnable({command_buffer:?}, {depth_write_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_write_enable)(
            command_buffer,
            depth_write_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthCompareOp.html>"]
fn vk_cmd_set_depth_compare_op(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_compare_op: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthCompareOp({command_buffer:?}, {depth_compare_op:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_compare_op)(
            command_buffer,
            depth_compare_op,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBoundsTestEnable.html>"]
fn vk_cmd_set_depth_bounds_test_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_bounds_test_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthBoundsTestEnable({command_buffer:?}, {depth_bounds_test_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_bounds_test_enable)(
            command_buffer,
            depth_bounds_test_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilTestEnable.html>"]
fn vk_cmd_set_stencil_test_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let stencil_test_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetStencilTestEnable({command_buffer:?}, {stencil_test_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_stencil_test_enable)(
            command_buffer,
            stencil_test_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetStencilOp.html>"]
fn vk_cmd_set_stencil_op(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let face_mask: NonDisposableHandle = packet.read();
    let fail_op: NonDisposableHandle = packet.read();
    let pass_op: NonDisposableHandle = packet.read();
    let depth_fail_op: NonDisposableHandle = packet.read();
    let compare_op: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetStencilOp({command_buffer:?}, {face_mask:?}, {fail_op:?}, {pass_op:?}, {depth_fail_op:?}, {compare_op:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_stencil_op)(
            command_buffer,
            face_mask,
            fail_op,
            pass_op,
            depth_fail_op,
            compare_op,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPatchControlPointsEXT.html>"]
fn vk_cmd_set_patch_control_points_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let patch_control_points: u32 = packet.read();
    trace!("called vkCmdSetPatchControlPointsEXT({command_buffer:?}, {patch_control_points:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_patch_control_points_ext)(
            command_buffer,
            patch_control_points,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizerDiscardEnable.html>"]
fn vk_cmd_set_rasterizer_discard_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let rasterizer_discard_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetRasterizerDiscardEnable({command_buffer:?}, {rasterizer_discard_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_rasterizer_discard_enable)(
            command_buffer,
            rasterizer_discard_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBiasEnable.html>"]
fn vk_cmd_set_depth_bias_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_bias_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthBiasEnable({command_buffer:?}, {depth_bias_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_bias_enable)(
            command_buffer,
            depth_bias_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEXT.html>"]
fn vk_cmd_set_logic_op_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let logic_op: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetLogicOpEXT({command_buffer:?}, {logic_op:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_logic_op_ext)(
            command_buffer,
            logic_op,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPrimitiveRestartEnable.html>"]
fn vk_cmd_set_primitive_restart_enable(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let primitive_restart_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetPrimitiveRestartEnable({command_buffer:?}, {primitive_restart_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_primitive_restart_enable)(
            command_buffer,
            primitive_restart_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetTessellationDomainOriginEXT.html>"]
fn vk_cmd_set_tessellation_domain_origin_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let domain_origin: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetTessellationDomainOriginEXT({command_buffer:?}, {domain_origin:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_tessellation_domain_origin_ext)(
            command_buffer,
            domain_origin,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClampEnableEXT.html>"]
fn vk_cmd_set_depth_clamp_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_clamp_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthClampEnableEXT({command_buffer:?}, {depth_clamp_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_clamp_enable_ext)(
            command_buffer,
            depth_clamp_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetPolygonModeEXT.html>"]
fn vk_cmd_set_polygon_mode_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let polygon_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetPolygonModeEXT({command_buffer:?}, {polygon_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_polygon_mode_ext)(
            command_buffer,
            polygon_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationSamplesEXT.html>"]
fn vk_cmd_set_rasterization_samples_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let rasterization_samples: vk::SampleCountFlags = packet.read();
    trace!("called vkCmdSetRasterizationSamplesEXT({command_buffer:?}, {rasterization_samples:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_rasterization_samples_ext)(
            command_buffer,
            rasterization_samples,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleMaskEXT.html>"]
fn vk_cmd_set_sample_mask_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let samples: vk::SampleCountFlags = packet.read();
    let p_sample_mask: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetSampleMaskEXT({command_buffer:?}, {samples:?}, {p_sample_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_sample_mask_ext)(
            command_buffer,
            samples,
            p_sample_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToCoverageEnableEXT.html>"]
fn vk_cmd_set_alpha_to_coverage_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let alpha_to_coverage_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetAlphaToCoverageEnableEXT({command_buffer:?}, {alpha_to_coverage_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_alpha_to_coverage_enable_ext)(
            command_buffer,
            alpha_to_coverage_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetAlphaToOneEnableEXT.html>"]
fn vk_cmd_set_alpha_to_one_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let alpha_to_one_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetAlphaToOneEnableEXT({command_buffer:?}, {alpha_to_one_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_alpha_to_one_enable_ext)(
            command_buffer,
            alpha_to_one_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLogicOpEnableEXT.html>"]
fn vk_cmd_set_logic_op_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let logic_op_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetLogicOpEnableEXT({command_buffer:?}, {logic_op_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_logic_op_enable_ext)(
            command_buffer,
            logic_op_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEnableEXT.html>"]
fn vk_cmd_set_color_blend_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_attachment: u32 = packet.read();
    let attachment_count: u32 = packet.read();
    let p_color_blend_enables: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetColorBlendEnableEXT({command_buffer:?}, {first_attachment:?}, {attachment_count:?}, {p_color_blend_enables:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_color_blend_enable_ext)(
            command_buffer,
            first_attachment,
            attachment_count,
            p_color_blend_enables,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendEquationEXT.html>"]
fn vk_cmd_set_color_blend_equation_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_attachment: u32 = packet.read();
    let attachment_count: u32 = packet.read();
    let p_color_blend_equations: *const VkColorBlendEquationEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetColorBlendEquationEXT({command_buffer:?}, {first_attachment:?}, {attachment_count:?}, {p_color_blend_equations:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_color_blend_equation_ext)(
            command_buffer,
            first_attachment,
            attachment_count,
            p_color_blend_equations,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteMaskEXT.html>"]
fn vk_cmd_set_color_write_mask_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_attachment: u32 = packet.read();
    let attachment_count: u32 = packet.read();
    let p_color_write_masks: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetColorWriteMaskEXT({command_buffer:?}, {first_attachment:?}, {attachment_count:?}, {p_color_write_masks:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_color_write_mask_ext)(
            command_buffer,
            first_attachment,
            attachment_count,
            p_color_write_masks,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRasterizationStreamEXT.html>"]
fn vk_cmd_set_rasterization_stream_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let rasterization_stream: u32 = packet.read();
    trace!("called vkCmdSetRasterizationStreamEXT({command_buffer:?}, {rasterization_stream:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_rasterization_stream_ext)(
            command_buffer,
            rasterization_stream,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetConservativeRasterizationModeEXT.html>"]
fn vk_cmd_set_conservative_rasterization_mode_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let conservative_rasterization_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetConservativeRasterizationModeEXT({command_buffer:?}, {conservative_rasterization_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_conservative_rasterization_mode_ext)(
            command_buffer,
            conservative_rasterization_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetExtraPrimitiveOverestimationSizeEXT.html>"]
fn vk_cmd_set_extra_primitive_overestimation_size_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let extra_primitive_overestimation_size: f32 = packet.read();
    trace!("called vkCmdSetExtraPrimitiveOverestimationSizeEXT({command_buffer:?}, {extra_primitive_overestimation_size:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_extra_primitive_overestimation_size_ext)(
            command_buffer,
            extra_primitive_overestimation_size,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipEnableEXT.html>"]
fn vk_cmd_set_depth_clip_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let depth_clip_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthClipEnableEXT({command_buffer:?}, {depth_clip_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_clip_enable_ext)(
            command_buffer,
            depth_clip_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetSampleLocationsEnableEXT.html>"]
fn vk_cmd_set_sample_locations_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let sample_locations_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetSampleLocationsEnableEXT({command_buffer:?}, {sample_locations_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_sample_locations_enable_ext)(
            command_buffer,
            sample_locations_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorBlendAdvancedEXT.html>"]
fn vk_cmd_set_color_blend_advanced_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_attachment: u32 = packet.read();
    let attachment_count: u32 = packet.read();
    let p_color_blend_advanced: *const VkColorBlendAdvancedEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetColorBlendAdvancedEXT({command_buffer:?}, {first_attachment:?}, {attachment_count:?}, {p_color_blend_advanced:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_color_blend_advanced_ext)(
            command_buffer,
            first_attachment,
            attachment_count,
            p_color_blend_advanced,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetProvokingVertexModeEXT.html>"]
fn vk_cmd_set_provoking_vertex_mode_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let provoking_vertex_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetProvokingVertexModeEXT({command_buffer:?}, {provoking_vertex_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_provoking_vertex_mode_ext)(
            command_buffer,
            provoking_vertex_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineRasterizationModeEXT.html>"]
fn vk_cmd_set_line_rasterization_mode_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let line_rasterization_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetLineRasterizationModeEXT({command_buffer:?}, {line_rasterization_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_line_rasterization_mode_ext)(
            command_buffer,
            line_rasterization_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetLineStippleEnableEXT.html>"]
fn vk_cmd_set_line_stipple_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let stippled_line_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetLineStippleEnableEXT({command_buffer:?}, {stippled_line_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_line_stipple_enable_ext)(
            command_buffer,
            stippled_line_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthClipNegativeOneToOneEXT.html>"]
fn vk_cmd_set_depth_clip_negative_one_to_one_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let negative_one_to_one: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetDepthClipNegativeOneToOneEXT({command_buffer:?}, {negative_one_to_one:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_clip_negative_one_to_one_ext)(
            command_buffer,
            negative_one_to_one,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportWScalingEnableNV.html>"]
fn vk_cmd_set_viewport_wscaling_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let viewport_wscaling_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetViewportWScalingEnableNV({command_buffer:?}, {viewport_wscaling_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport_wscaling_enable_nv)(
            command_buffer,
            viewport_wscaling_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetViewportSwizzleNV.html>"]
fn vk_cmd_set_viewport_swizzle_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let first_viewport: u32 = packet.read();
    let viewport_count: u32 = packet.read();
    let p_viewport_swizzles: *const VkViewportSwizzleNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetViewportSwizzleNV({command_buffer:?}, {first_viewport:?}, {viewport_count:?}, {p_viewport_swizzles:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_viewport_swizzle_nv)(
            command_buffer,
            first_viewport,
            viewport_count,
            p_viewport_swizzles,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorEnableNV.html>"]
fn vk_cmd_set_coverage_to_color_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_to_color_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetCoverageToColorEnableNV({command_buffer:?}, {coverage_to_color_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_to_color_enable_nv)(
            command_buffer,
            coverage_to_color_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageToColorLocationNV.html>"]
fn vk_cmd_set_coverage_to_color_location_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_to_color_location: u32 = packet.read();
    trace!("called vkCmdSetCoverageToColorLocationNV({command_buffer:?}, {coverage_to_color_location:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_to_color_location_nv)(
            command_buffer,
            coverage_to_color_location,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationModeNV.html>"]
fn vk_cmd_set_coverage_modulation_mode_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_modulation_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetCoverageModulationModeNV({command_buffer:?}, {coverage_modulation_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_modulation_mode_nv)(
            command_buffer,
            coverage_modulation_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableEnableNV.html>"]
fn vk_cmd_set_coverage_modulation_table_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_modulation_table_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetCoverageModulationTableEnableNV({command_buffer:?}, {coverage_modulation_table_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_modulation_table_enable_nv)(
            command_buffer,
            coverage_modulation_table_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageModulationTableNV.html>"]
fn vk_cmd_set_coverage_modulation_table_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_modulation_table_count: u32 = packet.read();
    let p_coverage_modulation_table: *const f32 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetCoverageModulationTableNV({command_buffer:?}, {coverage_modulation_table_count:?}, {p_coverage_modulation_table:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_modulation_table_nv)(
            command_buffer,
            coverage_modulation_table_count,
            p_coverage_modulation_table,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetShadingRateImageEnableNV.html>"]
fn vk_cmd_set_shading_rate_image_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let shading_rate_image_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetShadingRateImageEnableNV({command_buffer:?}, {shading_rate_image_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_shading_rate_image_enable_nv)(
            command_buffer,
            shading_rate_image_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetCoverageReductionModeNV.html>"]
fn vk_cmd_set_coverage_reduction_mode_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let coverage_reduction_mode: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetCoverageReductionModeNV({command_buffer:?}, {coverage_reduction_mode:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_coverage_reduction_mode_nv)(
            command_buffer,
            coverage_reduction_mode,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRepresentativeFragmentTestEnableNV.html>"]
fn vk_cmd_set_representative_fragment_test_enable_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let representative_fragment_test_enable: NonDisposableHandle = packet.read();
    trace!("called vkCmdSetRepresentativeFragmentTestEnableNV({command_buffer:?}, {representative_fragment_test_enable:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_representative_fragment_test_enable_nv)(
            command_buffer,
            representative_fragment_test_enable,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreatePrivateDataSlot.html>"]
fn vk_create_private_data_slot(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkPrivateDataSlotCreateInfo = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_private_data_slot: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreatePrivateDataSlot({device:?}, {p_create_info:?}, {p_allocator:?}, {p_private_data_slot:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_private_data_slot)(
            device,
            p_create_info,
            p_allocator,
            p_private_data_slot,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_private_data_slot);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyPrivateDataSlot.html>"]
fn vk_destroy_private_data_slot(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let private_data_slot: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyPrivateDataSlot({device:?}, {private_data_slot:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_private_data_slot)(
            device,
            private_data_slot,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetPrivateData.html>"]
fn vk_set_private_data(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let object_type: NonDisposableHandle = packet.read();
    let object_handle: u64 = packet.read();
    let private_data_slot: NonDisposableHandle = packet.read();
    let data: u64 = packet.read();
    trace!("called vkSetPrivateData({device:?}, {object_type:?}, {object_handle:?}, {private_data_slot:?}, {data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_private_data)(
            device,
            object_type,
            object_handle,
            private_data_slot,
            data,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPrivateData.html>"]
fn vk_get_private_data(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let object_type: NonDisposableHandle = packet.read();
    let object_handle: u64 = packet.read();
    let private_data_slot: NonDisposableHandle = packet.read();
    let p_data: *mut u64 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPrivateData({device:?}, {object_type:?}, {object_handle:?}, {private_data_slot:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_private_data)(
            device,
            object_type,
            object_handle,
            private_data_slot,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBuffer2.html>"]
fn vk_cmd_copy_buffer2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_copy_buffer_info: *const VkCopyBufferInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyBuffer2({command_buffer:?}, {p_copy_buffer_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_buffer2)(
            command_buffer,
            p_copy_buffer_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImage2.html>"]
fn vk_cmd_copy_image2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_copy_image_info: *const VkCopyImageInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyImage2({command_buffer:?}, {p_copy_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_image2)(
            command_buffer,
            p_copy_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage2.html>"]
fn vk_cmd_blit_image2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_blit_image_info: *const VkBlitImageInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBlitImage2({command_buffer:?}, {p_blit_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_blit_image2)(
            command_buffer,
            p_blit_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage2.html>"]
fn vk_cmd_copy_buffer_to_image2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_copy_buffer_to_image_info: *const VkCopyBufferToImageInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyBufferToImage2({command_buffer:?}, {p_copy_buffer_to_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_buffer_to_image2)(
            command_buffer,
            p_copy_buffer_to_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyImageToBuffer2.html>"]
fn vk_cmd_copy_image_to_buffer2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_copy_image_to_buffer_info: *const VkCopyImageToBufferInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyImageToBuffer2({command_buffer:?}, {p_copy_image_to_buffer_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_image_to_buffer2)(
            command_buffer,
            p_copy_image_to_buffer_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdResolveImage2.html>"]
fn vk_cmd_resolve_image2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_resolve_image_info: *const VkResolveImageInfo2 = packet.read_nullable_raw_ptr();
    trace!("called vkCmdResolveImage2({command_buffer:?}, {p_resolve_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_resolve_image2)(
            command_buffer,
            p_resolve_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateKHR.html>"]
fn vk_cmd_set_fragment_shading_rate_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_fragment_size: *const VkExtent2D = packet.read_nullable_raw_ptr();
    let combiner_ops: [NonDisposableHandle; 2] = packet.read();
    trace!("called vkCmdSetFragmentShadingRateKHR({command_buffer:?}, {p_fragment_size:?}, {combiner_ops:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_fragment_shading_rate_khr)(
            command_buffer,
            p_fragment_size,
            combiner_ops,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceFragmentShadingRatesKHR.html>"]
fn vk_get_physical_device_fragment_shading_rates_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_fragment_shading_rate_count, p_fragment_shading_rates) = packet.read_and_allocate_vk_array_count::<VkPhysicalDeviceFragmentShadingRateKHR>();
    trace!("called vkGetPhysicalDeviceFragmentShadingRatesKHR({physical_device:?}, {p_fragment_shading_rate_count:?}, {p_fragment_shading_rates:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_fragment_shading_rates_khr)(
            physical_device,
            &mut p_fragment_shading_rate_count,
            p_fragment_shading_rates,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_fragment_shading_rate_count, p_fragment_shading_rates);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetFragmentShadingRateEnumNV.html>"]
fn vk_cmd_set_fragment_shading_rate_enum_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let shading_rate: NonDisposableHandle = packet.read();
    let combiner_ops: [NonDisposableHandle; 2] = packet.read();
    trace!("called vkCmdSetFragmentShadingRateEnumNV({command_buffer:?}, {shading_rate:?}, {combiner_ops:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_fragment_shading_rate_enum_nv)(
            command_buffer,
            shading_rate,
            combiner_ops,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureBuildSizesKHR.html>"]
fn vk_get_acceleration_structure_build_sizes_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let build_type: NonDisposableHandle = packet.read();
    let p_build_info: *const VkAccelerationStructureBuildGeometryInfoKHR = packet.read_nullable_raw_ptr();
    let p_max_primitive_counts: *const u32 = packet.read_nullable_raw_ptr();
    let p_size_info: *mut VkAccelerationStructureBuildSizesInfoKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetAccelerationStructureBuildSizesKHR({device:?}, {build_type:?}, {p_build_info:?}, {p_max_primitive_counts:?}, {p_size_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_acceleration_structure_build_sizes_khr)(
            device,
            build_type,
            p_build_info,
            p_max_primitive_counts,
            p_size_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_size_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetVertexInputEXT.html>"]
fn vk_cmd_set_vertex_input_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let vertex_binding_description_count: u32 = packet.read();
    let p_vertex_binding_descriptions: *const VkVertexInputBindingDescription2EXT = packet.read_nullable_raw_ptr();
    let vertex_attribute_description_count: u32 = packet.read();
    let p_vertex_attribute_descriptions: *const VkVertexInputAttributeDescription2EXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetVertexInputEXT({command_buffer:?}, {vertex_binding_description_count:?}, {p_vertex_binding_descriptions:?}, {vertex_attribute_description_count:?}, {p_vertex_attribute_descriptions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_vertex_input_ext)(
            command_buffer,
            vertex_binding_description_count,
            p_vertex_binding_descriptions,
            vertex_attribute_description_count,
            p_vertex_attribute_descriptions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetColorWriteEnableEXT.html>"]
fn vk_cmd_set_color_write_enable_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let attachment_count: u32 = packet.read();
    let p_color_write_enables: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetColorWriteEnableEXT({command_buffer:?}, {attachment_count:?}, {p_color_write_enables:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_color_write_enable_ext)(
            command_buffer,
            attachment_count,
            p_color_write_enables,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetEvent2.html>"]
fn vk_cmd_set_event2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    let p_dependency_info: *const VkDependencyInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetEvent2({command_buffer:?}, {event:?}, {p_dependency_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_event2)(
            command_buffer,
            event,
            p_dependency_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdResetEvent2.html>"]
fn vk_cmd_reset_event2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event: NonDisposableHandle = packet.read();
    let stage_mask: NonDisposableHandle = packet.read();
    trace!("called vkCmdResetEvent2({command_buffer:?}, {event:?}, {stage_mask:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_reset_event2)(
            command_buffer,
            event,
            stage_mask,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWaitEvents2.html>"]
fn vk_cmd_wait_events2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let event_count: u32 = packet.read();
    let p_events: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_dependency_infos: *const VkDependencyInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdWaitEvents2({command_buffer:?}, {event_count:?}, {p_events:?}, {p_dependency_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_wait_events2)(
            command_buffer,
            event_count,
            p_events,
            p_dependency_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPipelineBarrier2.html>"]
fn vk_cmd_pipeline_barrier2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_dependency_info: *const VkDependencyInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPipelineBarrier2({command_buffer:?}, {p_dependency_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_pipeline_barrier2)(
            command_buffer,
            p_dependency_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueSubmit2.html>"]
fn vk_queue_submit2(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let submit_count: u32 = packet.read();
    let p_submits: *const VkSubmitInfo2 = packet.read_nullable_raw_ptr();
    let fence: NonDisposableHandle = packet.read();
    trace!("called vkQueueSubmit2({queue:?}, {submit_count:?}, {p_submits:?}, {fence:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_submit2)(
            queue,
            submit_count,
            p_submits,
            fence,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteTimestamp2.html>"]
fn vk_cmd_write_timestamp2(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let stage: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let query: u32 = packet.read();
    trace!("called vkCmdWriteTimestamp2({command_buffer:?}, {stage:?}, {query_pool:?}, {query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_timestamp2)(
            command_buffer,
            stage,
            query_pool,
            query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteBufferMarker2AMD.html>"]
fn vk_cmd_write_buffer_marker2_amd(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let stage: NonDisposableHandle = packet.read();
    let dst_buffer: NonDisposableHandle = packet.read();
    let dst_offset: NonDisposableHandle = packet.read();
    let marker: u32 = packet.read();
    trace!("called vkCmdWriteBufferMarker2AMD({command_buffer:?}, {stage:?}, {dst_buffer:?}, {dst_offset:?}, {marker:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_buffer_marker2_amd)(
            command_buffer,
            stage,
            dst_buffer,
            dst_offset,
            marker,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetQueueCheckpointData2NV.html>"]
fn vk_get_queue_checkpoint_data2_nv(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let (mut p_checkpoint_data_count, p_checkpoint_data) = packet.read_and_allocate_vk_array_count::<VkCheckpointData2NV>();
    trace!("called vkGetQueueCheckpointData2NV({queue:?}, {p_checkpoint_data_count:?}, {p_checkpoint_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_queue_checkpoint_data2_nv)(
            queue,
            &mut p_checkpoint_data_count,
            p_checkpoint_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_checkpoint_data_count, p_checkpoint_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToImageEXT.html>"]
fn vk_copy_memory_to_image_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_copy_memory_to_image_info: *const VkCopyMemoryToImageInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyMemoryToImageEXT({device:?}, {p_copy_memory_to_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_memory_to_image_ext)(
            device,
            p_copy_memory_to_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyImageToMemoryEXT.html>"]
fn vk_copy_image_to_memory_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_copy_image_to_memory_info: *const VkCopyImageToMemoryInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyImageToMemoryEXT({device:?}, {p_copy_image_to_memory_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_image_to_memory_ext)(
            device,
            p_copy_image_to_memory_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyImageToImageEXT.html>"]
fn vk_copy_image_to_image_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_copy_image_to_image_info: *const VkCopyImageToImageInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyImageToImageEXT({device:?}, {p_copy_image_to_image_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_image_to_image_ext)(
            device,
            p_copy_image_to_image_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkTransitionImageLayoutEXT.html>"]
fn vk_transition_image_layout_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let transition_count: u32 = packet.read();
    let p_transitions: *const VkHostImageLayoutTransitionInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkTransitionImageLayoutEXT({device:?}, {transition_count:?}, {p_transitions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_transition_image_layout_ext)(
            device,
            transition_count,
            p_transitions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoCapabilitiesKHR.html>"]
fn vk_get_physical_device_video_capabilities_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_video_profile: *const VkVideoProfileInfoKHR = packet.read_nullable_raw_ptr();
    let p_capabilities: *mut VkVideoCapabilitiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceVideoCapabilitiesKHR({physical_device:?}, {p_video_profile:?}, {p_capabilities:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_video_capabilities_khr)(
            physical_device,
            p_video_profile,
            p_capabilities,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_capabilities);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoFormatPropertiesKHR.html>"]
fn vk_get_physical_device_video_format_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_video_format_info: *const VkPhysicalDeviceVideoFormatInfoKHR = packet.read_nullable_raw_ptr();
    let (mut p_video_format_property_count, p_video_format_properties) = packet.read_and_allocate_vk_array_count::<VkVideoFormatPropertiesKHR>();
    trace!("called vkGetPhysicalDeviceVideoFormatPropertiesKHR({physical_device:?}, {p_video_format_info:?}, {p_video_format_property_count:?}, {p_video_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_video_format_properties_khr)(
            physical_device,
            p_video_format_info,
            &mut p_video_format_property_count,
            p_video_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_video_format_property_count, p_video_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR.html>"]
fn vk_get_physical_device_video_encode_quality_level_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_quality_level_info: *const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR = packet.read_nullable_raw_ptr();
    let p_quality_level_properties: *mut VkVideoEncodeQualityLevelPropertiesKHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR({physical_device:?}, {p_quality_level_info:?}, {p_quality_level_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_video_encode_quality_level_properties_khr)(
            physical_device,
            p_quality_level_info,
            p_quality_level_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_quality_level_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionKHR.html>"]
fn vk_create_video_session_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkVideoSessionCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_video_session: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateVideoSessionKHR({device:?}, {p_create_info:?}, {p_allocator:?}, {p_video_session:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_video_session_khr)(
            device,
            p_create_info,
            p_allocator,
            p_video_session,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_video_session);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionKHR.html>"]
fn vk_destroy_video_session_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let video_session: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyVideoSessionKHR({device:?}, {video_session:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_video_session_khr)(
            device,
            video_session,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateVideoSessionParametersKHR.html>"]
fn vk_create_video_session_parameters_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkVideoSessionParametersCreateInfoKHR = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_video_session_parameters: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateVideoSessionParametersKHR({device:?}, {p_create_info:?}, {p_allocator:?}, {p_video_session_parameters:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_video_session_parameters_khr)(
            device,
            p_create_info,
            p_allocator,
            p_video_session_parameters,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_video_session_parameters);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUpdateVideoSessionParametersKHR.html>"]
fn vk_update_video_session_parameters_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let video_session_parameters: NonDisposableHandle = packet.read();
    let p_update_info: *const VkVideoSessionParametersUpdateInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkUpdateVideoSessionParametersKHR({device:?}, {video_session_parameters:?}, {p_update_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_update_video_session_parameters_khr)(
            device,
            video_session_parameters,
            p_update_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetEncodedVideoSessionParametersKHR.html>"]
fn vk_get_encoded_video_session_parameters_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_video_session_parameters_info: *const VkVideoEncodeSessionParametersGetInfoKHR = packet.read_nullable_raw_ptr();
    let p_feedback_info: *mut VkVideoEncodeSessionParametersFeedbackInfoKHR = packet.read_nullable_raw_ptr_mut();
    let p_data_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetEncodedVideoSessionParametersKHR({device:?}, {p_video_session_parameters_info:?}, {p_feedback_info:?}, {p_data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_encoded_video_session_parameters_khr)(
            device,
            p_video_session_parameters_info,
            p_feedback_info,
            p_data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_feedback_info);
    response.write_raw_ptr(p_data_size);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyVideoSessionParametersKHR.html>"]
fn vk_destroy_video_session_parameters_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let video_session_parameters: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyVideoSessionParametersKHR({device:?}, {video_session_parameters:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_video_session_parameters_khr)(
            device,
            video_session_parameters,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetVideoSessionMemoryRequirementsKHR.html>"]
fn vk_get_video_session_memory_requirements_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let video_session: NonDisposableHandle = packet.read();
    let (mut p_memory_requirements_count, p_memory_requirements) = packet.read_and_allocate_vk_array_count::<VkVideoSessionMemoryRequirementsKHR>();
    trace!("called vkGetVideoSessionMemoryRequirementsKHR({device:?}, {video_session:?}, {p_memory_requirements_count:?}, {p_memory_requirements:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_video_session_memory_requirements_khr)(
            device,
            video_session,
            &mut p_memory_requirements_count,
            p_memory_requirements,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_memory_requirements_count, p_memory_requirements);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindVideoSessionMemoryKHR.html>"]
fn vk_bind_video_session_memory_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let video_session: NonDisposableHandle = packet.read();
    let bind_session_memory_info_count: u32 = packet.read();
    let p_bind_session_memory_infos: *const VkBindVideoSessionMemoryInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkBindVideoSessionMemoryKHR({device:?}, {video_session:?}, {bind_session_memory_info_count:?}, {p_bind_session_memory_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_video_session_memory_khr)(
            device,
            video_session,
            bind_session_memory_info_count,
            p_bind_session_memory_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDecodeVideoKHR.html>"]
fn vk_cmd_decode_video_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_decode_info: *const VkVideoDecodeInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDecodeVideoKHR({command_buffer:?}, {p_decode_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_decode_video_khr)(
            command_buffer,
            p_decode_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginVideoCodingKHR.html>"]
fn vk_cmd_begin_video_coding_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_begin_info: *const VkVideoBeginCodingInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginVideoCodingKHR({command_buffer:?}, {p_begin_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_video_coding_khr)(
            command_buffer,
            p_begin_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdControlVideoCodingKHR.html>"]
fn vk_cmd_control_video_coding_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_coding_control_info: *const VkVideoCodingControlInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdControlVideoCodingKHR({command_buffer:?}, {p_coding_control_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_control_video_coding_khr)(
            command_buffer,
            p_coding_control_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndVideoCodingKHR.html>"]
fn vk_cmd_end_video_coding_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_end_coding_info: *const VkVideoEndCodingInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdEndVideoCodingKHR({command_buffer:?}, {p_end_coding_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_video_coding_khr)(
            command_buffer,
            p_end_coding_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEncodeVideoKHR.html>"]
fn vk_cmd_encode_video_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_encode_info: *const VkVideoEncodeInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdEncodeVideoKHR({command_buffer:?}, {p_encode_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_encode_video_khr)(
            command_buffer,
            p_encode_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryNV.html>"]
fn vk_cmd_decompress_memory_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let decompress_region_count: u32 = packet.read();
    let p_decompress_memory_regions: *const VkDecompressMemoryRegionNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDecompressMemoryNV({command_buffer:?}, {decompress_region_count:?}, {p_decompress_memory_regions:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_decompress_memory_nv)(
            command_buffer,
            decompress_region_count,
            p_decompress_memory_regions,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDecompressMemoryIndirectCountNV.html>"]
fn vk_cmd_decompress_memory_indirect_count_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let indirect_commands_address: NonDisposableHandle = packet.read();
    let indirect_commands_count_address: NonDisposableHandle = packet.read();
    let stride: u32 = packet.read();
    trace!("called vkCmdDecompressMemoryIndirectCountNV({command_buffer:?}, {indirect_commands_address:?}, {indirect_commands_count_address:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_decompress_memory_indirect_count_nv)(
            command_buffer,
            indirect_commands_address,
            indirect_commands_count_address,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateCuModuleNVX.html>"]
fn vk_create_cu_module_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkCuModuleCreateInfoNVX = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_module: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateCuModuleNVX({device:?}, {p_create_info:?}, {p_allocator:?}, {p_module:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_cu_module_nvx)(
            device,
            p_create_info,
            p_allocator,
            p_module,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_module);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateCuFunctionNVX.html>"]
fn vk_create_cu_function_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkCuFunctionCreateInfoNVX = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_function: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateCuFunctionNVX({device:?}, {p_create_info:?}, {p_allocator:?}, {p_function:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_cu_function_nvx)(
            device,
            p_create_info,
            p_allocator,
            p_function,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_function);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyCuModuleNVX.html>"]
fn vk_destroy_cu_module_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let module: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyCuModuleNVX({device:?}, {module:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_cu_module_nvx)(
            device,
            module,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyCuFunctionNVX.html>"]
fn vk_destroy_cu_function_nvx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let function: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyCuFunctionNVX({device:?}, {function:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_cu_function_nvx)(
            device,
            function,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCuLaunchKernelNVX.html>"]
fn vk_cmd_cu_launch_kernel_nvx(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_launch_info: *const VkCuLaunchInfoNVX = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCuLaunchKernelNVX({command_buffer:?}, {p_launch_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_cu_launch_kernel_nvx)(
            command_buffer,
            p_launch_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutSizeEXT.html>"]
fn vk_get_descriptor_set_layout_size_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let p_layout_size_in_bytes: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorSetLayoutSizeEXT({device:?}, {layout:?}, {p_layout_size_in_bytes:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_set_layout_size_ext)(
            device,
            layout,
            p_layout_size_in_bytes,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_layout_size_in_bytes);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutBindingOffsetEXT.html>"]
fn vk_get_descriptor_set_layout_binding_offset_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let binding: u32 = packet.read();
    let p_offset: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorSetLayoutBindingOffsetEXT({device:?}, {layout:?}, {binding:?}, {p_offset:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_set_layout_binding_offset_ext)(
            device,
            layout,
            binding,
            p_offset,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_offset);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorEXT.html>"]
fn vk_get_descriptor_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_descriptor_info: *const VkDescriptorGetInfoEXT = packet.read_nullable_raw_ptr();
    let data_size: usize = packet.read();
    let p_descriptor: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorEXT({device:?}, {p_descriptor_info:?}, {data_size:?}, {p_descriptor:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_ext)(
            device,
            p_descriptor_info,
            data_size,
            p_descriptor,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_descriptor);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBuffersEXT.html>"]
fn vk_cmd_bind_descriptor_buffers_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let buffer_count: u32 = packet.read();
    let p_binding_infos: *const VkDescriptorBufferBindingInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindDescriptorBuffersEXT({command_buffer:?}, {buffer_count:?}, {p_binding_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_descriptor_buffers_ext)(
            command_buffer,
            buffer_count,
            p_binding_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsetsEXT.html>"]
fn vk_cmd_set_descriptor_buffer_offsets_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let first_set: u32 = packet.read();
    let set_count: u32 = packet.read();
    let p_buffer_indices: *const u32 = packet.read_nullable_raw_ptr();
    let p_offsets: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetDescriptorBufferOffsetsEXT({command_buffer:?}, {pipeline_bind_point:?}, {layout:?}, {first_set:?}, {set_count:?}, {p_buffer_indices:?}, {p_offsets:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_descriptor_buffer_offsets_ext)(
            command_buffer,
            pipeline_bind_point,
            layout,
            first_set,
            set_count,
            p_buffer_indices,
            p_offsets,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplersEXT.html>"]
fn vk_cmd_bind_descriptor_buffer_embedded_samplers_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let pipeline_bind_point: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    let set: u32 = packet.read();
    trace!("called vkCmdBindDescriptorBufferEmbeddedSamplersEXT({command_buffer:?}, {pipeline_bind_point:?}, {layout:?}, {set:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_descriptor_buffer_embedded_samplers_ext)(
            command_buffer,
            pipeline_bind_point,
            layout,
            set,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferOpaqueCaptureDescriptorDataEXT.html>"]
fn vk_get_buffer_opaque_capture_descriptor_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkBufferCaptureDescriptorDataInfoEXT = packet.read_nullable_raw_ptr();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetBufferOpaqueCaptureDescriptorDataEXT({device:?}, {p_info:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_opaque_capture_descriptor_data_ext)(
            device,
            p_info,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageOpaqueCaptureDescriptorDataEXT.html>"]
fn vk_get_image_opaque_capture_descriptor_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkImageCaptureDescriptorDataInfoEXT = packet.read_nullable_raw_ptr();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageOpaqueCaptureDescriptorDataEXT({device:?}, {p_info:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_opaque_capture_descriptor_data_ext)(
            device,
            p_info,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageViewOpaqueCaptureDescriptorDataEXT.html>"]
fn vk_get_image_view_opaque_capture_descriptor_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkImageViewCaptureDescriptorDataInfoEXT = packet.read_nullable_raw_ptr();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageViewOpaqueCaptureDescriptorDataEXT({device:?}, {p_info:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_view_opaque_capture_descriptor_data_ext)(
            device,
            p_info,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetSamplerOpaqueCaptureDescriptorDataEXT.html>"]
fn vk_get_sampler_opaque_capture_descriptor_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkSamplerCaptureDescriptorDataInfoEXT = packet.read_nullable_raw_ptr();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetSamplerOpaqueCaptureDescriptorDataEXT({device:?}, {p_info:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_sampler_opaque_capture_descriptor_data_ext)(
            device,
            p_info,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT.html>"]
fn vk_get_acceleration_structure_opaque_capture_descriptor_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT = packet.read_nullable_raw_ptr();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT({device:?}, {p_info:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_acceleration_structure_opaque_capture_descriptor_data_ext)(
            device,
            p_info,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetDeviceMemoryPriorityEXT.html>"]
fn vk_set_device_memory_priority_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let memory: NonDisposableHandle = packet.read();
    let priority: f32 = packet.read();
    trace!("called vkSetDeviceMemoryPriorityEXT({device:?}, {memory:?}, {priority:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_device_memory_priority_ext)(
            device,
            memory,
            priority,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkAcquireDrmDisplayEXT.html>"]
fn vk_acquire_drm_display_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let drm_fd: i32 = packet.read();
    let display: NonDisposableHandle = packet.read();
    trace!("called vkAcquireDrmDisplayEXT({physical_device:?}, {drm_fd:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_acquire_drm_display_ext)(
            physical_device,
            drm_fd,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDrmDisplayEXT.html>"]
fn vk_get_drm_display_ext(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let drm_fd: i32 = packet.read();
    let connector_id: u32 = packet.read();
    let display: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDrmDisplayEXT({physical_device:?}, {drm_fd:?}, {connector_id:?}, {display:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_drm_display_ext)(
            physical_device,
            drm_fd,
            connector_id,
            display,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(display);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWaitForPresentKHR.html>"]
fn vk_wait_for_present_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let present_id: u64 = packet.read();
    let timeout: u64 = packet.read();
    trace!("called vkWaitForPresentKHR({device:?}, {swapchain:?}, {present_id:?}, {timeout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_wait_for_present_khr)(
            device,
            swapchain,
            present_id,
            timeout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateBufferCollectionFUCHSIA.html>"]
fn vk_create_buffer_collection_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkBufferCollectionCreateInfoFUCHSIA = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_collection: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateBufferCollectionFUCHSIA({device:?}, {p_create_info:?}, {p_allocator:?}, {p_collection:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_buffer_collection_fuchsia)(
            device,
            p_create_info,
            p_allocator,
            p_collection,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_collection);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetBufferCollectionBufferConstraintsFUCHSIA.html>"]
fn vk_set_buffer_collection_buffer_constraints_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let collection: NonDisposableHandle = packet.read();
    let p_buffer_constraints_info: *const VkBufferConstraintsInfoFUCHSIA = packet.read_nullable_raw_ptr();
    trace!("called vkSetBufferCollectionBufferConstraintsFUCHSIA({device:?}, {collection:?}, {p_buffer_constraints_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_buffer_collection_buffer_constraints_fuchsia)(
            device,
            collection,
            p_buffer_constraints_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetBufferCollectionImageConstraintsFUCHSIA.html>"]
fn vk_set_buffer_collection_image_constraints_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let collection: NonDisposableHandle = packet.read();
    let p_image_constraints_info: *const VkImageConstraintsInfoFUCHSIA = packet.read_nullable_raw_ptr();
    trace!("called vkSetBufferCollectionImageConstraintsFUCHSIA({device:?}, {collection:?}, {p_image_constraints_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_buffer_collection_image_constraints_fuchsia)(
            device,
            collection,
            p_image_constraints_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyBufferCollectionFUCHSIA.html>"]
fn vk_destroy_buffer_collection_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let collection: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyBufferCollectionFUCHSIA({device:?}, {collection:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_buffer_collection_fuchsia)(
            device,
            collection,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetBufferCollectionPropertiesFUCHSIA.html>"]
fn vk_get_buffer_collection_properties_fuchsia(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let collection: NonDisposableHandle = packet.read();
    let p_properties: *mut VkBufferCollectionPropertiesFUCHSIA = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetBufferCollectionPropertiesFUCHSIA({device:?}, {collection:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_buffer_collection_properties_fuchsia)(
            device,
            collection,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateCudaModuleNV.html>"]
fn vk_create_cuda_module_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkCudaModuleCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_module: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateCudaModuleNV({device:?}, {p_create_info:?}, {p_allocator:?}, {p_module:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_cuda_module_nv)(
            device,
            p_create_info,
            p_allocator,
            p_module,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_module);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetCudaModuleCacheNV.html>"]
fn vk_get_cuda_module_cache_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let module: NonDisposableHandle = packet.read();
    let p_cache_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_cache_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetCudaModuleCacheNV({device:?}, {module:?}, {p_cache_size:?}, {p_cache_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_cuda_module_cache_nv)(
            device,
            module,
            p_cache_size,
            p_cache_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_cache_size);
    response.write_raw_ptr(p_cache_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateCudaFunctionNV.html>"]
fn vk_create_cuda_function_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkCudaFunctionCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_function: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateCudaFunctionNV({device:?}, {p_create_info:?}, {p_allocator:?}, {p_function:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_cuda_function_nv)(
            device,
            p_create_info,
            p_allocator,
            p_function,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_function);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaModuleNV.html>"]
fn vk_destroy_cuda_module_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let module: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyCudaModuleNV({device:?}, {module:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_cuda_module_nv)(
            device,
            module,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyCudaFunctionNV.html>"]
fn vk_destroy_cuda_function_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let function: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyCudaFunctionNV({device:?}, {function:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_cuda_function_nv)(
            device,
            function,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCudaLaunchKernelNV.html>"]
fn vk_cmd_cuda_launch_kernel_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_launch_info: *const VkCudaLaunchInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCudaLaunchKernelNV({command_buffer:?}, {p_launch_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_cuda_launch_kernel_nv)(
            command_buffer,
            p_launch_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBeginRendering.html>"]
fn vk_cmd_begin_rendering(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_rendering_info: *const VkRenderingInfo = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBeginRendering({command_buffer:?}, {p_rendering_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_begin_rendering)(
            command_buffer,
            p_rendering_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdEndRendering.html>"]
fn vk_cmd_end_rendering(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    trace!("called vkCmdEndRendering({command_buffer:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_end_rendering)(
            command_buffer,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetLayoutHostMappingInfoVALVE.html>"]
fn vk_get_descriptor_set_layout_host_mapping_info_valve(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_binding_reference: *const VkDescriptorSetBindingReferenceVALVE = packet.read_nullable_raw_ptr();
    let p_host_mapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorSetLayoutHostMappingInfoVALVE({device:?}, {p_binding_reference:?}, {p_host_mapping:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_set_layout_host_mapping_info_valve)(
            device,
            p_binding_reference,
            p_host_mapping,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_host_mapping);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDescriptorSetHostMappingVALVE.html>"]
fn vk_get_descriptor_set_host_mapping_valve(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let descriptor_set: NonDisposableHandle = packet.read();
    let pp_data: *mut *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDescriptorSetHostMappingVALVE({device:?}, {descriptor_set:?}, {pp_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_descriptor_set_host_mapping_valve)(
            device,
            descriptor_set,
            pp_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(pp_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateMicromapEXT.html>"]
fn vk_create_micromap_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkMicromapCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_micromap: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateMicromapEXT({device:?}, {p_create_info:?}, {p_allocator:?}, {p_micromap:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_micromap_ext)(
            device,
            p_create_info,
            p_allocator,
            p_micromap,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_micromap);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBuildMicromapsEXT.html>"]
fn vk_cmd_build_micromaps_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let info_count: u32 = packet.read();
    let p_infos: *const VkMicromapBuildInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBuildMicromapsEXT({command_buffer:?}, {info_count:?}, {p_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_build_micromaps_ext)(
            command_buffer,
            info_count,
            p_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBuildMicromapsEXT.html>"]
fn vk_build_micromaps_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let info_count: u32 = packet.read();
    let p_infos: *const VkMicromapBuildInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkBuildMicromapsEXT({device:?}, {deferred_operation:?}, {info_count:?}, {p_infos:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_build_micromaps_ext)(
            device,
            deferred_operation,
            info_count,
            p_infos,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyMicromapEXT.html>"]
fn vk_destroy_micromap_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let micromap: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyMicromapEXT({device:?}, {micromap:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_micromap_ext)(
            device,
            micromap,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapEXT.html>"]
fn vk_cmd_copy_micromap_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMicromapInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyMicromapEXT({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_micromap_ext)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapEXT.html>"]
fn vk_copy_micromap_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMicromapInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyMicromapEXT({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_micromap_ext)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMicromapToMemoryEXT.html>"]
fn vk_cmd_copy_micromap_to_memory_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMicromapToMemoryInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyMicromapToMemoryEXT({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_micromap_to_memory_ext)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyMicromapToMemoryEXT.html>"]
fn vk_copy_micromap_to_memory_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMicromapToMemoryInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyMicromapToMemoryEXT({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_micromap_to_memory_ext)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyMemoryToMicromapEXT.html>"]
fn vk_cmd_copy_memory_to_micromap_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMemoryToMicromapInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdCopyMemoryToMicromapEXT({command_buffer:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_copy_memory_to_micromap_ext)(
            command_buffer,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCopyMemoryToMicromapEXT.html>"]
fn vk_copy_memory_to_micromap_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let deferred_operation: NonDisposableHandle = packet.read();
    let p_info: *const VkCopyMemoryToMicromapInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCopyMemoryToMicromapEXT({device:?}, {deferred_operation:?}, {p_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_copy_memory_to_micromap_ext)(
            device,
            deferred_operation,
            p_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdWriteMicromapsPropertiesEXT.html>"]
fn vk_cmd_write_micromaps_properties_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let micromap_count: u32 = packet.read();
    let p_micromaps: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let query_type: NonDisposableHandle = packet.read();
    let query_pool: NonDisposableHandle = packet.read();
    let first_query: u32 = packet.read();
    trace!("called vkCmdWriteMicromapsPropertiesEXT({command_buffer:?}, {micromap_count:?}, {p_micromaps:?}, {query_type:?}, {query_pool:?}, {first_query:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_write_micromaps_properties_ext)(
            command_buffer,
            micromap_count,
            p_micromaps,
            query_type,
            query_pool,
            first_query,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkWriteMicromapsPropertiesEXT.html>"]
fn vk_write_micromaps_properties_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let micromap_count: u32 = packet.read();
    let p_micromaps: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let query_type: NonDisposableHandle = packet.read();
    let data_size: usize = packet.read();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    let stride: usize = packet.read();
    trace!("called vkWriteMicromapsPropertiesEXT({device:?}, {micromap_count:?}, {p_micromaps:?}, {query_type:?}, {data_size:?}, {p_data:?}, {stride:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_write_micromaps_properties_ext)(
            device,
            micromap_count,
            p_micromaps,
            query_type,
            data_size,
            p_data,
            stride,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceMicromapCompatibilityEXT.html>"]
fn vk_get_device_micromap_compatibility_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_version_info: *const VkMicromapVersionInfoEXT = packet.read_nullable_raw_ptr();
    let p_compatibility: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceMicromapCompatibilityEXT({device:?}, {p_version_info:?}, {p_compatibility:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_micromap_compatibility_ext)(
            device,
            p_version_info,
            p_compatibility,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_compatibility);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetMicromapBuildSizesEXT.html>"]
fn vk_get_micromap_build_sizes_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let build_type: NonDisposableHandle = packet.read();
    let p_build_info: *const VkMicromapBuildInfoEXT = packet.read_nullable_raw_ptr();
    let p_size_info: *mut VkMicromapBuildSizesInfoEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetMicromapBuildSizesEXT({device:?}, {build_type:?}, {p_build_info:?}, {p_size_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_micromap_build_sizes_ext)(
            device,
            build_type,
            p_build_info,
            p_size_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_size_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleIdentifierEXT.html>"]
fn vk_get_shader_module_identifier_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let shader_module: NonDisposableHandle = packet.read();
    let p_identifier: *mut VkShaderModuleIdentifierEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetShaderModuleIdentifierEXT({device:?}, {shader_module:?}, {p_identifier:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_shader_module_identifier_ext)(
            device,
            shader_module,
            p_identifier,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_identifier);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetShaderModuleCreateInfoIdentifierEXT.html>"]
fn vk_get_shader_module_create_info_identifier_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkShaderModuleCreateInfo = packet.read_nullable_raw_ptr();
    let p_identifier: *mut VkShaderModuleIdentifierEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetShaderModuleCreateInfoIdentifierEXT({device:?}, {p_create_info:?}, {p_identifier:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_shader_module_create_info_identifier_ext)(
            device,
            p_create_info,
            p_identifier,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_identifier);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetImageSubresourceLayout2KHR.html>"]
fn vk_get_image_subresource_layout2_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let image: NonDisposableHandle = packet.read();
    let p_subresource: *const VkImageSubresource2KHR = packet.read_nullable_raw_ptr();
    let p_layout: *mut VkSubresourceLayout2KHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetImageSubresourceLayout2KHR({device:?}, {image:?}, {p_subresource:?}, {p_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_image_subresource_layout2_khr)(
            device,
            image,
            p_subresource,
            p_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPipelinePropertiesEXT.html>"]
fn vk_get_pipeline_properties_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_pipeline_info: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    let p_pipeline_properties: *mut VkBaseOutStructure = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetPipelinePropertiesEXT({device:?}, {p_pipeline_info:?}, {p_pipeline_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_pipeline_properties_ext)(
            device,
            p_pipeline_info,
            p_pipeline_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipeline_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkExportMetalObjectsEXT.html>"]
fn vk_export_metal_objects_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_metal_objects_info: *mut VkExportMetalObjectsInfoEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkExportMetalObjectsEXT({device:?}, {p_metal_objects_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_export_metal_objects_ext)(
            device,
            p_metal_objects_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_metal_objects_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetFramebufferTilePropertiesQCOM.html>"]
fn vk_get_framebuffer_tile_properties_qcom(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let framebuffer: NonDisposableHandle = packet.read();
    let (mut p_properties_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkTilePropertiesQCOM>();
    trace!("called vkGetFramebufferTilePropertiesQCOM({device:?}, {framebuffer:?}, {p_properties_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_framebuffer_tile_properties_qcom)(
            device,
            framebuffer,
            &mut p_properties_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_properties_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDynamicRenderingTilePropertiesQCOM.html>"]
fn vk_get_dynamic_rendering_tile_properties_qcom(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_rendering_info: *const VkRenderingInfo = packet.read_nullable_raw_ptr();
    let p_properties: *mut VkTilePropertiesQCOM = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDynamicRenderingTilePropertiesQCOM({device:?}, {p_rendering_info:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_dynamic_rendering_tile_properties_qcom)(
            device,
            p_rendering_info,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceOpticalFlowImageFormatsNV.html>"]
fn vk_get_physical_device_optical_flow_image_formats_nv(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let p_optical_flow_image_format_info: *const VkOpticalFlowImageFormatInfoNV = packet.read_nullable_raw_ptr();
    let (mut p_format_count, p_image_format_properties) = packet.read_and_allocate_vk_array_count::<VkOpticalFlowImageFormatPropertiesNV>();
    trace!("called vkGetPhysicalDeviceOpticalFlowImageFormatsNV({physical_device:?}, {p_optical_flow_image_format_info:?}, {p_format_count:?}, {p_image_format_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_optical_flow_image_formats_nv)(
            physical_device,
            p_optical_flow_image_format_info,
            &mut p_format_count,
            p_image_format_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_format_count, p_image_format_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateOpticalFlowSessionNV.html>"]
fn vk_create_optical_flow_session_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_create_info: *const VkOpticalFlowSessionCreateInfoNV = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_session: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateOpticalFlowSessionNV({device:?}, {p_create_info:?}, {p_allocator:?}, {p_session:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_optical_flow_session_nv)(
            device,
            p_create_info,
            p_allocator,
            p_session,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_session);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyOpticalFlowSessionNV.html>"]
fn vk_destroy_optical_flow_session_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let session: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyOpticalFlowSessionNV({device:?}, {session:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_optical_flow_session_nv)(
            device,
            session,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkBindOpticalFlowSessionImageNV.html>"]
fn vk_bind_optical_flow_session_image_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let session: NonDisposableHandle = packet.read();
    let binding_point: NonDisposableHandle = packet.read();
    let view: NonDisposableHandle = packet.read();
    let layout: NonDisposableHandle = packet.read();
    trace!("called vkBindOpticalFlowSessionImageNV({device:?}, {session:?}, {binding_point:?}, {view:?}, {layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_bind_optical_flow_session_image_nv)(
            device,
            session,
            binding_point,
            view,
            layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdOpticalFlowExecuteNV.html>"]
fn vk_cmd_optical_flow_execute_nv(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let session: NonDisposableHandle = packet.read();
    let p_execute_info: *const VkOpticalFlowExecuteInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkCmdOpticalFlowExecuteNV({command_buffer:?}, {session:?}, {p_execute_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_optical_flow_execute_nv)(
            command_buffer,
            session,
            p_execute_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceFaultInfoEXT.html>"]
fn vk_get_device_fault_info_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_fault_counts: *mut VkDeviceFaultCountsEXT = packet.read_nullable_raw_ptr_mut();
    let p_fault_info: *mut VkDeviceFaultInfoEXT = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceFaultInfoEXT({device:?}, {p_fault_counts:?}, {p_fault_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_fault_info_ext)(
            device,
            p_fault_counts,
            p_fault_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_fault_counts);
    response.write_raw_ptr(p_fault_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDepthBias2EXT.html>"]
fn vk_cmd_set_depth_bias2_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_depth_bias_info: *const VkDepthBiasInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetDepthBias2EXT({command_buffer:?}, {p_depth_bias_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_depth_bias2_ext)(
            command_buffer,
            p_depth_bias_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkReleaseSwapchainImagesEXT.html>"]
fn vk_release_swapchain_images_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_release_info: *const VkReleaseSwapchainImagesInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkReleaseSwapchainImagesEXT({device:?}, {p_release_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_release_swapchain_images_ext)(
            device,
            p_release_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetDeviceImageSubresourceLayoutKHR.html>"]
fn vk_get_device_image_subresource_layout_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_info: *const VkDeviceImageSubresourceInfoKHR = packet.read_nullable_raw_ptr();
    let p_layout: *mut VkSubresourceLayout2KHR = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetDeviceImageSubresourceLayoutKHR({device:?}, {p_info:?}, {p_layout:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_device_image_subresource_layout_khr)(
            device,
            p_info,
            p_layout,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_layout);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkMapMemory2KHR.html>"]
fn vk_map_memory2_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_memory_map_info: *const VkMemoryMapInfoKHR = packet.read_nullable_raw_ptr();
    let pp_data: *mut *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkMapMemory2KHR({device:?}, {p_memory_map_info:?}, {pp_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_map_memory2_khr)(
            device,
            p_memory_map_info,
            pp_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(pp_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkUnmapMemory2KHR.html>"]
fn vk_unmap_memory2_khr(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let p_memory_unmap_info: *const VkMemoryUnmapInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkUnmapMemory2KHR({device:?}, {p_memory_unmap_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_unmap_memory2_khr)(
            device,
            p_memory_unmap_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateShadersEXT.html>"]
fn vk_create_shaders_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkShaderCreateInfoEXT = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_shaders: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateShadersEXT({device:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_shaders:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_shaders_ext)(
            device,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_shaders,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_shaders);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkDestroyShaderEXT.html>"]
fn vk_destroy_shader_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let shader: NonDisposableHandle = packet.read();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    trace!("called vkDestroyShaderEXT({device:?}, {shader:?}, {p_allocator:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_destroy_shader_ext)(
            device,
            shader,
            p_allocator,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetShaderBinaryDataEXT.html>"]
fn vk_get_shader_binary_data_ext(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let shader: NonDisposableHandle = packet.read();
    let p_data_size: *mut usize = packet.read_nullable_raw_ptr_mut();
    let p_data: *mut c_void = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetShaderBinaryDataEXT({device:?}, {shader:?}, {p_data_size:?}, {p_data:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_shader_binary_data_ext)(
            device,
            shader,
            p_data_size,
            p_data,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_data_size);
    response.write_raw_ptr(p_data);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindShadersEXT.html>"]
fn vk_cmd_bind_shaders_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let stage_count: u32 = packet.read();
    let p_stages: *const vk::ShaderStageFlags = packet.read_nullable_raw_ptr();
    let p_shaders: *const NonDisposableHandle = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindShadersEXT({command_buffer:?}, {stage_count:?}, {p_stages:?}, {p_shaders:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_shaders_ext)(
            command_buffer,
            stage_count,
            p_stages,
            p_shaders,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetScreenBufferPropertiesQNX.html>"]
fn vk_get_screen_buffer_properties_qnx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let buffer: *const usize = packet.read_nullable_raw_ptr();
    let p_properties: *mut VkScreenBufferPropertiesQNX = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetScreenBufferPropertiesQNX({device:?}, {buffer:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_screen_buffer_properties_qnx)(
            device,
            buffer,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR.html>"]
fn vk_get_physical_device_cooperative_matrix_properties_khr(mut packet: Packet) {
    let physical_device: NonDisposableHandle = packet.read();
    let (mut p_property_count, p_properties) = packet.read_and_allocate_vk_array_count::<VkCooperativeMatrixPropertiesKHR>();
    trace!("called vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR({physical_device:?}, {p_property_count:?}, {p_properties:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_physical_device_cooperative_matrix_properties_khr)(
            physical_device,
            &mut p_property_count,
            p_properties,
        )
    };

    let mut response = packet.write_response(None);
    response.write_vk_array(p_property_count, p_properties);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetExecutionGraphPipelineScratchSizeAMDX.html>"]
fn vk_get_execution_graph_pipeline_scratch_size_amdx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let execution_graph: NonDisposableHandle = packet.read();
    let p_size_info: *mut VkExecutionGraphPipelineScratchSizeAMDX = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetExecutionGraphPipelineScratchSizeAMDX({device:?}, {execution_graph:?}, {p_size_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_execution_graph_pipeline_scratch_size_amdx)(
            device,
            execution_graph,
            p_size_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_size_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetExecutionGraphPipelineNodeIndexAMDX.html>"]
fn vk_get_execution_graph_pipeline_node_index_amdx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let execution_graph: NonDisposableHandle = packet.read();
    let p_node_info: *const VkPipelineShaderStageNodeCreateInfoAMDX = packet.read_nullable_raw_ptr();
    let p_node_index: *mut u32 = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetExecutionGraphPipelineNodeIndexAMDX({device:?}, {execution_graph:?}, {p_node_info:?}, {p_node_index:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_execution_graph_pipeline_node_index_amdx)(
            device,
            execution_graph,
            p_node_info,
            p_node_index,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_node_index);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCreateExecutionGraphPipelinesAMDX.html>"]
fn vk_create_execution_graph_pipelines_amdx(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let pipeline_cache: NonDisposableHandle = packet.read();
    let create_info_count: u32 = packet.read();
    let p_create_infos: *const VkExecutionGraphPipelineCreateInfoAMDX = packet.read_nullable_raw_ptr();
    let p_allocator: *const VkAllocationCallbacks = packet.read_nullable_raw_ptr();
    let p_pipelines: *mut NonDisposableHandle = packet.read_nullable_raw_ptr_mut();
    trace!("called vkCreateExecutionGraphPipelinesAMDX({device:?}, {pipeline_cache:?}, {create_info_count:?}, {p_create_infos:?}, {p_allocator:?}, {p_pipelines:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_create_execution_graph_pipelines_amdx)(
            device,
            pipeline_cache,
            create_info_count,
            p_create_infos,
            p_allocator,
            p_pipelines,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_pipelines);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdInitializeGraphScratchMemoryAMDX.html>"]
fn vk_cmd_initialize_graph_scratch_memory_amdx(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let scratch: NonDisposableHandle = packet.read();
    trace!("called vkCmdInitializeGraphScratchMemoryAMDX({command_buffer:?}, {scratch:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_initialize_graph_scratch_memory_amdx)(
            command_buffer,
            scratch,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphAMDX.html>"]
fn vk_cmd_dispatch_graph_amdx(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let scratch: NonDisposableHandle = packet.read();
    let p_count_info: *const VkDispatchGraphCountInfoAMDX = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDispatchGraphAMDX({command_buffer:?}, {scratch:?}, {p_count_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch_graph_amdx)(
            command_buffer,
            scratch,
            p_count_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphIndirectAMDX.html>"]
fn vk_cmd_dispatch_graph_indirect_amdx(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let scratch: NonDisposableHandle = packet.read();
    let p_count_info: *const VkDispatchGraphCountInfoAMDX = packet.read_nullable_raw_ptr();
    trace!("called vkCmdDispatchGraphIndirectAMDX({command_buffer:?}, {scratch:?}, {p_count_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch_graph_indirect_amdx)(
            command_buffer,
            scratch,
            p_count_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdDispatchGraphIndirectCountAMDX.html>"]
fn vk_cmd_dispatch_graph_indirect_count_amdx(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let scratch: NonDisposableHandle = packet.read();
    let count_info: NonDisposableHandle = packet.read();
    trace!("called vkCmdDispatchGraphIndirectCountAMDX({command_buffer:?}, {scratch:?}, {count_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_dispatch_graph_indirect_count_amdx)(
            command_buffer,
            scratch,
            count_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorSets2KHR.html>"]
fn vk_cmd_bind_descriptor_sets2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_bind_descriptor_sets_info: *const VkBindDescriptorSetsInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindDescriptorSets2KHR({command_buffer:?}, {p_bind_descriptor_sets_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_descriptor_sets2_khr)(
            command_buffer,
            p_bind_descriptor_sets_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushConstants2KHR.html>"]
fn vk_cmd_push_constants2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_push_constants_info: *const VkPushConstantsInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushConstants2KHR({command_buffer:?}, {p_push_constants_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_constants2_khr)(
            command_buffer,
            p_push_constants_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSet2KHR.html>"]
fn vk_cmd_push_descriptor_set2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_push_descriptor_set_info: *const VkPushDescriptorSetInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushDescriptorSet2KHR({command_buffer:?}, {p_push_descriptor_set_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_descriptor_set2_khr)(
            command_buffer,
            p_push_descriptor_set_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdPushDescriptorSetWithTemplate2KHR.html>"]
fn vk_cmd_push_descriptor_set_with_template2_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_push_descriptor_set_with_template_info: *const VkPushDescriptorSetWithTemplateInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdPushDescriptorSetWithTemplate2KHR({command_buffer:?}, {p_push_descriptor_set_with_template_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_push_descriptor_set_with_template2_khr)(
            command_buffer,
            p_push_descriptor_set_with_template_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetDescriptorBufferOffsets2EXT.html>"]
fn vk_cmd_set_descriptor_buffer_offsets2_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_set_descriptor_buffer_offsets_info: *const VkSetDescriptorBufferOffsetsInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetDescriptorBufferOffsets2EXT({command_buffer:?}, {p_set_descriptor_buffer_offsets_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_descriptor_buffer_offsets2_ext)(
            command_buffer,
            p_set_descriptor_buffer_offsets_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBindDescriptorBufferEmbeddedSamplers2EXT.html>"]
fn vk_cmd_bind_descriptor_buffer_embedded_samplers2_ext(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_bind_descriptor_buffer_embedded_samplers_info: *const VkBindDescriptorBufferEmbeddedSamplersInfoEXT = packet.read_nullable_raw_ptr();
    trace!("called vkCmdBindDescriptorBufferEmbeddedSamplers2EXT({command_buffer:?}, {p_bind_descriptor_buffer_embedded_samplers_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_bind_descriptor_buffer_embedded_samplers2_ext)(
            command_buffer,
            p_bind_descriptor_buffer_embedded_samplers_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetLatencySleepModeNV.html>"]
fn vk_set_latency_sleep_mode_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_sleep_mode_info: *const VkLatencySleepModeInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkSetLatencySleepModeNV({device:?}, {swapchain:?}, {p_sleep_mode_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_latency_sleep_mode_nv)(
            device,
            swapchain,
            p_sleep_mode_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkLatencySleepNV.html>"]
fn vk_latency_sleep_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_sleep_info: *const VkLatencySleepInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkLatencySleepNV({device:?}, {swapchain:?}, {p_sleep_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_latency_sleep_nv)(
            device,
            swapchain,
            p_sleep_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkSetLatencyMarkerNV.html>"]
fn vk_set_latency_marker_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_latency_marker_info: *const VkSetLatencyMarkerInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkSetLatencyMarkerNV({device:?}, {swapchain:?}, {p_latency_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_set_latency_marker_nv)(
            device,
            swapchain,
            p_latency_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkGetLatencyTimingsNV.html>"]
fn vk_get_latency_timings_nv(mut packet: Packet) {
    let device: NonDisposableHandle = packet.read();
    let swapchain: NonDisposableHandle = packet.read();
    let p_latency_marker_info: *mut VkGetLatencyMarkerInfoNV = packet.read_nullable_raw_ptr_mut();
    trace!("called vkGetLatencyTimingsNV({device:?}, {swapchain:?}, {p_latency_marker_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_get_latency_timings_nv)(
            device,
            swapchain,
            p_latency_marker_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write_raw_ptr(p_latency_marker_info);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkQueueNotifyOutOfBandNV.html>"]
fn vk_queue_notify_out_of_band_nv(mut packet: Packet) {
    let queue: NonDisposableHandle = packet.read();
    let p_queue_type_info: *const VkOutOfBandQueueTypeInfoNV = packet.read_nullable_raw_ptr();
    trace!("called vkQueueNotifyOutOfBandNV({queue:?}, {p_queue_type_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_queue_notify_out_of_band_nv)(
            queue,
            p_queue_type_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRenderingAttachmentLocationsKHR.html>"]
fn vk_cmd_set_rendering_attachment_locations_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_location_info: *const VkRenderingAttachmentLocationInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetRenderingAttachmentLocationsKHR({command_buffer:?}, {p_location_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_rendering_attachment_locations_khr)(
            command_buffer,
            p_location_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}

#[doc = "<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdSetRenderingInputAttachmentIndicesKHR.html>"]
fn vk_cmd_set_rendering_input_attachment_indices_khr(mut packet: Packet) {
    let command_buffer: NonDisposableHandle = packet.read();
    let p_location_info: *const VkRenderingInputAttachmentIndexInfoKHR = packet.read_nullable_raw_ptr();
    trace!("called vkCmdSetRenderingInputAttachmentIndicesKHR({command_buffer:?}, {p_location_info:?})");

    let result = unsafe {
        (crate::FUNCTION_ADDRESS_TABLE.vk_cmd_set_rendering_input_attachment_indices_khr)(
            command_buffer,
            p_location_info,
        )
    };

    let mut response = packet.write_response(None);
    response.write(result);
    response.send();
}
