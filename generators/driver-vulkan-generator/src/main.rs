use std::{collections::HashSet, fs, path::Path};

use itertools::Itertools;
use vk_parse::{CommandDefinition, Extension, NameWithType};

const DESIRED_API: &str = "vulkan";
const INDENTATION: &str = "    ";

fn main() {
    let mut directory = std::env::current_dir().unwrap();
    while !directory.ends_with("wie") {
        directory = directory
            .parent()
            .expect("expected command to be called inside wie directory")
            .to_path_buf()
    }

    generate(
        &directory.join("generators/driver-vulkan-generator/Vulkan-Headers/registry/vk.xml"),
        &directory.join("crates/driver-vulkan/src/generated"),
    );
}

fn generate(vk_headers_path: &Path, source_directory: &Path) {
    let (spec, _errors) = vk_parse::parse_file(vk_headers_path).expect("invalid XML file");

    let extensions: Vec<&Extension> = spec
        .0
        .iter()
        .find_map(|x| match x {
            vk_parse::RegistryChild::Extensions(ext) => Some(ext),
            _ => None,
        })
        .expect("extension")
        .children
        .iter()
        .filter(|e| {
            if let Some(supported) = &e.supported {
                contains_desired_api(supported) ||
                // VK_ANDROID_native_buffer is for internal use only, but types defined elsewhere
                // reference enum extension constants.  Exempt the extension from this check until
                // types are properly folded in with their extension (where applicable).
                e.name == "VK_ANDROID_native_buffer"
            } else {
                true
            }
        })
        .collect();

    let features_children = spec
        .0
        .iter()
        .filter_map(|x| match x {
            vk_parse::RegistryChild::Feature(f) => Some(f),
            _ => None,
        })
        .filter(|feature| contains_desired_api(&feature.api))
        .flat_map(|features| &features.children);

    let extension_children = extensions.iter().flat_map(|extension| &extension.children);

    let required_commands = features_children
        .chain(extension_children)
        .filter_map(|x| match x {
            vk_parse::FeatureChild::Require { api, items, .. } => Some((api, items)),
            _ => None,
        })
        .filter(|(api, _items)| matches!(api.as_deref(), None | Some(DESIRED_API)))
        .flat_map(|(_api, items)| items)
        .fold(HashSet::new(), |mut acc, elem| {
            if let vk_parse::InterfaceItem::Command { name, .. } = elem {
                acc.insert(name.as_str());
            }
            acc
        });

    let commands: Vec<&CommandDefinition> = spec
        .0
        .iter()
        .filter_map(|x| match x {
            vk_parse::RegistryChild::Commands(cmds) => Some(cmds),
            _ => None,
        })
        .flat_map(|x| &x.children)
        .filter_map(|x| match x {
            vk_parse::Command::Definition(def) => Some(def),
            _ => None,
        })
        .filter(|cmd| required_commands.contains(&cmd.proto.name.as_str()))
        .unique_by(|x| &x.proto.name)
        .collect();

    let mut builder = String::new();
    builder.push_str("//! THIS FILE IS GENERATED BY TOOL, DO NOT MODIFY.\n\nuse ash::vk;\n");

    for definition in commands {
        generate_command(&mut builder, definition);
    }

    let path = source_directory.join("definitions.rs");
    fs::create_dir_all(path.parent().unwrap()).expect("create directories");
    fs::write(path, builder).expect("write to a file");
}

fn generate_command(builder: &mut String, definition: &CommandDefinition) {
    builder.push_str("\n#[no_mangle]\n#[doc = \"<https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/");
    builder.push_str(&definition.proto.name);
    builder.push_str(".html>\"]\nextern \"C\" fn ");
    builder.push_str(&definition.proto.name);
    builder.push('(');

    if !definition.params.is_empty() {
        builder.push('\n');
        for param in definition.params.iter().unique_by(|x| &x.definition.name) {
            push_indentation(builder, 1);

            match param.definition.name == "type" {
                true => builder.push_str("r#type"),
                false => to_snake_case(builder, &param.definition.name),
            }

            builder.push_str(": ");
            builder.push_str(&to_rust_type(&param.definition));
            builder.push_str(",\n");
        }
    }

    builder.push(')');
    let return_type = to_rust_type(&definition.proto);
    if return_type != "std::ffi::c_void" {
        builder.push_str(" -> ");
        builder.push_str(&return_type);
    }
    builder.push_str(" {\n");

    push_indentation(builder, 1);
    builder.push_str("std::fs::write(\"C:\\\\Users\\\\Vixen\\\\Desktop\\\\wie-logs\\\\");
    builder.push_str(&definition.proto.name);
    builder.push_str(".txt\", \"whoa\").unwrap();\n    std::thread::sleep(std::time::Duration::from_millis(1000));\n");

    push_indentation(builder, 1);
    builder.push_str("unimplemented!();\n");

    builder.push_str("}\n");
}

fn push_indentation(builder: &mut String, count: usize) {
    for _ in 0..count {
        builder.push_str(INDENTATION);
    }
}

fn to_snake_case(builder: &mut String, text: &str) {
    builder.push_str(&text[..1].to_ascii_lowercase());
    for c in text[1..].chars() {
        if c.is_ascii_uppercase() {
            builder.push('_');
            builder.push(c.to_ascii_lowercase());
        } else {
            builder.push(c);
        }
    }
}

fn to_rust_type(name_with_type: &NameWithType) -> String {
    let type_name = name_with_type.type_name.as_ref().unwrap();
    let mut n = type_name.replace("Vk", "");

    n = match n.as_str() {
        "void" => "std::ffi::c_void".into(),
        "uint64_t" => "u64".into(),
        "uint32_t" => "u32".into(),
        "uint16_t" => "u16".into(),
        "size_t" => "isize".into(),
        "int" => "std::os::raw::c_int".into(),
        "int32_t" => "i32".into(),
        "float" => "f32".into(),
        "char" => n,
        "SurfaceCounterFlagBitsEXT" => "vk::SurfaceCounterFlagsEXT".into(),
        "DebugUtilsMessageSeverityFlagBitsEXT" => "vk::DebugUtilsMessageSeverityFlagsEXT".into(),
        "PipelineStageFlagBits" => "vk::PipelineStageFlags".into(),
        "ExternalMemoryHandleTypeFlagBits" => "vk::ExternalMemoryHandleTypeFlags".into(),
        "SampleCountFlagBits" => "vk::SampleCountFlags".into(),
        "ShaderStageFlagBits" => "vk::ShaderStageFlags".into(),
        _ => {
            n.insert_str(0, "vk::");
            n
        }
    };

    let mut i = 0;
    while let Some(p) = name_with_type.code[i..].chars().position(|x| x == '*') {
        match name_with_type.code[i..].contains("const ") {
            true => n.insert_str(0, "*const "),
            false => n.insert_str(0, "*mut "),
        }
        i += p + 1;
    }

    n
}

fn contains_desired_api(api: &str) -> bool {
    api.split(',').any(|n| n == DESIRED_API)
}
