use std::{fs, path::Path};

use itertools::Itertools;
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use vkxml::{
    EnumerationElement, EnumsElement, ExtensionElement, ExtensionSpecificationElement,
    RegistryElement,
};

const VK_STRUCTURE_TYPE: &str = "VK_STRUCTURE_TYPE_";

use crate::{contains_desired_api, vulkan_types::TypeVulkan, DESIRED_API};

pub fn generate(
    project_directory: &Path,
    spec: &vk_parse::Registry,
    registry: &vkxml::Registry,
    types: &TypeVulkan,
) {
    let structure_types = get_structure_types(spec, registry, types);

    let serializer = serializer(&structure_types);
    let deserializer = deserializer(&structure_types);
    let cdebugger = cdebugger(&structure_types);

    let result = quote! {
        //! THIS FILE IS GENERATED BY TOOL, DO NOT MODIFY.

        use ash::vk::StructureType;
        use cdump::{CDumpReader, CDumpWriter, CSerialize, CDeserialize};
        use crate::generated::vulkan_types::*;
        use std::{slice, mem, ptr, ffi::c_void, fmt::Debug};

        #serializer
        #deserializer
        #cdebugger
    };

    let path = project_directory.join("crates/driver-common-vulkan/src/generated/p_next.rs");
    fs::create_dir_all(path.parent().unwrap()).expect("create directories");
    fs::write(path, result.to_string()).expect("write to a file");
}

fn serializer(structure_types: &[(String, String)]) -> TokenStream {
    generate_impl(
        structure_types,
        |quotes| {
            quote! {
                pub(crate) unsafe fn p_next_serializer<T: CDumpWriter>(buf: &mut T, obj: *const c_void) -> usize {
                    unsafe fn unimplemented<T: CDumpWriter>(buf: &mut T, ty: StructureType) -> usize {
                        let size = mem::size_of::<StructureType>();
                        buf.push_slice(slice::from_raw_parts(&ty as *const StructureType as *const u8, size));
                        size
                    }

                    buf.align::<StructureType>();
                    let ty = *(obj as *const StructureType);
                    match ty {
                        #quotes
                        StructureType::LOADER_INSTANCE_CREATE_INFO => unimplemented(buf, ty),
                        StructureType::LOADER_DEVICE_CREATE_INFO => unimplemented(buf, ty),
                        _ => panic!("Unknown structure type: {:?}", ty),
                    }
                }
            }
        },
        |id, type_name| {
            quote! {
                StructureType::#id => {
                    let obj = &*(obj as *const #type_name);
                    obj.serialize(buf);
                    mem::size_of::<#type_name>()
                },
            }
        },
    )
}

fn deserializer(structure_types: &[(String, String)]) -> TokenStream {
    generate_impl(
        structure_types,
        |quotes| {
            quote! {
                pub(crate) unsafe fn p_next_deserializer<T: CDumpReader>(buf: &mut T) -> *mut c_void {
                    unsafe fn unimplemented<T: CDumpReader>(buf: &mut T) -> *mut c_void {
                        buf.add_read(mem::size_of::<StructureType>());
                        ptr::null_mut()
                    }

                    buf.align::<StructureType>();
                    let ptr = buf.as_mut_ptr_at::<c_void>(buf.get_read());
                    let ty = *(ptr as *const StructureType);
                    match ty {
                        #quotes
                        StructureType::LOADER_INSTANCE_CREATE_INFO => return unimplemented(buf),
                        StructureType::LOADER_DEVICE_CREATE_INFO => return unimplemented(buf),
                        _ => panic!("Unknown structure type: {:?}", ty),
                    }
                    ptr
                }
            }
        },
        |id, type_name| {
            quote! {
                StructureType::#id => {
                    let dst = &mut *(ptr as *mut #type_name);
                    buf.add_read(mem::size_of::<#type_name>());
                    #type_name::deserialize_to_without_shallow_copy(buf, dst);
                },
            }
        },
    )
}

fn cdebugger(structure_types: &[(String, String)]) -> TokenStream {
    generate_impl(
        structure_types,
        |quotes| {
            quote! {
            pub(crate) unsafe fn p_next_cdebugger(obj: *const c_void) -> &'static dyn Debug {
                let ty = *(obj as *const StructureType);
                match ty {
                    #quotes
                    StructureType::LOADER_INSTANCE_CREATE_INFO => &"<not implemented yet, see #1>",
                    StructureType::LOADER_DEVICE_CREATE_INFO => &"<not implemented yet, see #2>",
                    _ => panic!("Unknown structure type: {:?}", ty),
                }
            }}
        },
        |id, type_name| {
            quote! {
                StructureType::#id => &*(obj as *const #type_name),
            }
        },
    )
}

fn generate_impl<F1, F2>(structure_types: &[(String, String)], body: F1, element: F2) -> TokenStream
where
    F1: FnOnce(TokenStream) -> TokenStream,
    F2: Fn(Ident, Ident) -> TokenStream,
{
    let mut quotes = Vec::new();
    for (scream_name, type_name) in structure_types {
        let id = Ident::new(&scream_name[VK_STRUCTURE_TYPE.len()..], Span::call_site());
        let type_name = Ident::new(type_name, Span::call_site());

        quotes.push(element(id, type_name));
    }

    let quotes = quotes.into_iter().collect::<TokenStream>();
    body(quotes)
}

fn get_structure_types(
    spec: &vk_parse::Registry,
    registry: &vkxml::Registry,
    types: &TypeVulkan,
) -> Vec<(String, String)> {
    let features = spec
        .0
        .iter()
        .filter_map(|x| match x {
            vk_parse::RegistryChild::Feature(ext) => Some(ext),
            _ => None,
        })
        .filter(|feature| contains_desired_api(&feature.api))
        .flat_map(|x| get_vk_structure_type_from_extension(x));

    registry
        .elements
        .iter()
        .flat_map(|x| match x {
            RegistryElement::Enums(x) => Some(
                x.elements
                    .iter()
                    .filter_map(|x| match x {
                        EnumsElement::Enumeration(x) => Some(x),
                        _ => None,
                    })
                    .flat_map(|x| &x.elements)
                    .filter_map(|x| match x {
                        EnumerationElement::Enum(x) => Some(x),
                        _ => None,
                    })
                    .filter(|x| x.name.starts_with("VK_STRUCTURE_TYPE"))
                    .map(|x| &x.name)
                    .collect_vec(),
            ),
            RegistryElement::Extensions(x) => Some(
                x.elements
                    .iter()
                    .flat_map(|x| &x.elements)
                    .filter_map(|x| match x {
                        ExtensionElement::Require(x) => Some(x),
                        _ => None,
                    })
                    .flat_map(|x| &x.elements)
                    .filter_map(|x| match x {
                        ExtensionSpecificationElement::Enum(x) => Some(x),
                        _ => None,
                    })
                    .filter(|x| x.name.starts_with("VK_STRUCTURE_TYPE"))
                    .map(|x| &x.name)
                    .collect_vec(),
            ),
            _ => None,
        })
        .flatten()
        .chain(features)
        .unique()
        .filter_map(|x| {
            let y = x[VK_STRUCTURE_TYPE.len()..]
                .replace('_', "")
                .to_ascii_lowercase();
            for ty in &types.types {
                if let Some(name) = &ty.name {
                    let i = get_index_of_prefix_end(name);
                    if y == name[i..].to_ascii_lowercase() {
                        return Some((x.clone(), name.clone()));
                    }
                }
            }
            None
        })
        .collect_vec()
}

fn get_vk_structure_type_from_extension(extension: &vk_parse::Feature) -> Vec<&String> {
    extension
        .children
        .iter()
        .filter_map(|x| match x {
            vk_parse::ExtensionChild::Require { api, items, .. } => Some((api, items)),
            _ => None,
        })
        .filter(|(api, _items)| match &api {
            Some(api) => api == DESIRED_API,
            None => true,
        })
        .flat_map(|(_api, items)| items)
        .filter_map(|x| match x {
            vk_parse::InterfaceItem::Enum(x) => Some(x),
            _ => None,
        })
        .filter(|x| x.deprecated.is_none())
        .filter(|x| match get_extend_from_enum(x) {
            Some(extends) => extends == "VkStructureType",
            None => false,
        })
        .map(|x| &x.name)
        .collect_vec()
}

fn get_extend_from_enum(enum_: &vk_parse::Enum) -> Option<&String> {
    match &enum_.spec {
        vk_parse::EnumSpec::Alias { extends, .. } => extends.as_ref(),
        vk_parse::EnumSpec::Offset { extends, .. } => Some(extends),
        vk_parse::EnumSpec::Bitpos { extends, .. } => extends.as_ref(),
        vk_parse::EnumSpec::Value { extends, .. } => extends.as_ref(),
        _ => None,
    }
}

fn get_index_of_prefix_end(text: &str) -> usize {
    if text.starts_with("Vk") {
        2
    } else {
        0
    }
}
